# -*- mode:org; fill-column:79; -*-

#+TITLE:Building Serverless Web Applications with React & AWS Amplify
#+AUTHOR:Nader Dabit
#+DATE:2019-02-06

#+TEXINFO:@insertcopying

* Introduction

  #+CINDEX:course description
  #+CINDEX:React
  #+CINDEX:web application
  #+CINDEX:cloud-based web application
  React makes it intuitive to build real-world web applications.  But in
  reality, you need to use a host of other services to get the app in front of
  real users.  /This course walks you through setup and implementation to get
  your cloud-based application up and running./

  You’ll learn to set up:

  #+CINDEX:AWS Amplify
  #+CINDEX:Amazon Cognito
  #+CINDEX:GraphQL
  #+CINDEX:AWS AppSync
  #+CINDEX:Amazon S3
  #+CINDEX:Lambda functions
  #+CINDEX:deployment using Amazon S3
  - a new project in [[https://aws-amplify.github.io/][AWS Amplify]] configured to your React app
  - user authentication with [[https://aws.amazon.com/cognito/][Amazon Cognito]]
  - manage [[https://graphql.org/][GraphQL]] with [[https://aws.amazon.com/appsync/][AWS AppSync]]
  - image storage and retrieval with [[https://aws.amazon.com/s3/][Amazon S3]]
  - text translation via [[https://aws.amazon.com/lambda/][Lambda functions]]
  - and finally, deployment of your application on AWS using Amazon S3


  #+CINDEX:React application, serverless
  #+CINDEX:serverless React application
  You’ll finish the course ready to quickly and easily deploy your
  serverless React application, so users can start using and enjoying
  it right away.

* Set Up the AWS Amplify CLI

  #+CINDEX:AWS Amplify
  #+CINDEX:Amplify CLI
  #+CINDEX:Amplify, configure project
  #+CINDEX:configure Amplify
  #+CINDEX:IAM user
  #+CINDEX:new project, Amplify
  #+CINDEX:Amplify project, new
  In this lesson we’ll show how to install the Amplify Command-Line Interface
  (CLI), {{{pxref(Install the Amplify CLI)}}} [fn:1], and then configure it,
  {{{pxref(Amplify Configure)}}}, with an IAM user, {{{pxref(Manage
  Users)}}} [fn:2], so we can begin creating new Amplify projects.

- Install AWS Amplify CLI
- Configure with Amazon IAM user
- Setup Access Keys

** Install and Configure the AWS Amplify CLI

- Install AWS Amplify CLI
- Configure AWS Amplify CLI

   #+CINDEX:CLI, install
   #+CINDEX:install CLI
   #+CINDEX:@command{npm install}
   #+CINDEX:@command{amplify configure}
   #+CINDEX:configure Amplify
   #+CINDEX:AWS console
   #+CINDEX:console, AWS
   #+CINDEX:AWS account
   #+CINDEX:account, AWS
   #+CINDEX:log in, AWS console
   [00:01] To install, [[*Get Started With Amplify][Get Started with Amplify]], and we'll [[https://github.com/aws-amplify/amplify-cli#install-the-cli][install the
  CLI]] [fn:3] by running either:
   : npm install -g @aws-amplify/cli
   : yarn global add @aws-mplify/ci

#+BEGIN_SRC sh :results output append :exports both :eval never-export
which amplify && echo not necessary || yarn global add @aws-amplify/cli
#+END_SRC

#+RESULTS:
   : yarn global v1.13.0
   : [1/4] Resolving packages...
   : [2/4] Fetching packages...
   : [3/4] Linking dependencies...
   : [4/4] Building fresh packages...
   : success Installed "@aws-amplify/cli@1.1.4" with binaries:
   :       - amplify
   : Done in 47.85s.
   : /usr/local/bin/amplify
   : not necessary


{{{noindent}}}Now that the CLI has been installed, we'll run:
: amplify configure
#+CINDEX:AWS access credentials
#+CINDEX:access credentials, AWS
#+CINDEX:credentials, access, AWS
{{{noindent}}}to configure the CLI with the user from our AWS account.[fn:4]
This should open up the AWS console.  Once you're logged into the console,
jump back to the command-line.

** Setup and Configure AWS IAM User

   #+CINDEX:AWS region
   #+CINDEX:region, AWS
   #+CINDEX:us-east-1, AWS region
   #+CINDEX:username
   #+CINDEX:new user, create
   #+CINDEX:IAM dashboard
   #+CINDEX:dashboard, IAM
   #+CINDEX:AWS account
   #+CINDEX:accountm, AWS
   [00:33] We're next prompted to specify an AWS region. [fn:5] For me, that's
   =us-east-1=.  Now we can give a =username= for the new user that we're about
   to create.  I'll give mine the =username= of ~amplify-egghead-cli-user~.
   This should open up the [[https://aws.amazon.com/iam/][IAM dashboard]] in our [[https://aws.amazon.com/][AWS account]].

   #+CINDEX:IAM user
   #+CINDEX:settings, preconfigured
   #+CINDEX:access key ID
   #+CINDEX:secret access key
   #+CINDEX:keys, access and secret access
   [00:53] This IAM user has some preconfigured settings that we can accept by
   clicking {{{key(Next Permissions)}}}, {{{key(Next Review)}}}, and
   {{{key(Create User)}}}.  Once the user's been created, we're given an
   =access key ID= and a =secret access key=.

*** Add user

**** Set user details

#+CINDEX:user details
You can add multiple users at once with the same access type and permissions.

- User name: =amplify-user=

{{{subheading(Select AWS access type)}}}

#+CINDEX:access AWS
Select how these users will access AWS. Access keys and autogenerated passwords
are provided in the last step.

- Access type

  #+CINDEX:access type
  #+CINDEX:programmatic access
    [x] Programmatic access

    Enables an access key ID and secret access key for the AWS API, CLI, SDK,
    and other development tools.

    #+CINDEX:management console access
    [ ] AWS Management Console access

    Enables a password that allows users to sign-in to the AWS Management
    Console

**** Set Permissions

#+CINDEX:permissions
| Add user to group | Copy permissions from existing user | Attach existing policies directory |

#+CINDEX:permission policies
#+CINDEX:policies, permission
{{{key(Create policies)}}}

|     | Policy name         | Type         | Used as            | Description                    |
|-----+---------------------+--------------+--------------------+--------------------------------|
|     |                     |              |                    | <30>                           |
| [x] | AdministratorAccess | Job function | Permissions policy | Provides full access to AWS services |
|     | ...                 |              |                    |                                |

**** Set permissions boundary

#+CINDEX:permissions boundary
Set a permissions boundary to control the maximum permissions this user can
have. This is an advanced feature used to delegate permission management to
others.

[x] Create user without a permissions boundary

[ ] Use a permissions boundary to control the maximum user permissions

**** Add Tags (optional)

#+CINDEX:tags, IAM
IAM tags are key-value pairs you can add to your user. Tags can include user
information, such as an email address, or can be descriptive, such as a job
title. You can use the tags to organize, track, or control access for this
user.

| Key         | Value (optional) | Remove |
|-------------+------------------+--------|
| Add new key |                  |        |

You can add 50 more tags.

**** Review

Review your choices. After you create the user, you can view and download the
autogenerated password and access key.

- User details

  - User name: :: =amplify-user=

  - AWS access type :: Programmatic access - with an access key

  - Permissions boundary :: Permissions boundary is not set

- Permissions summary

  The following policies will be attached to the user shown above.

  | Type           | Name                  |
  |----------------+-----------------------|
  | Managed policy | =AdministratorAccess= |

- Tags

  /No tags were added./

**** Security Credentials

#+CINDEX:security credentials
{{{heading(Success)}}}

You successfully created the users shown below. You can view and download user
security credentials. You can also email users instructions for signing in to
the AWS Management Console. This is the last time these credentials will be
available to download. However, you can create new credentials at any time.

Users with AWS Management Console access can sign-in at:

- https://730126810716.signin.aws.amazon.com/console

|     | User           | Access key ID        | Secret access key |
|-----+----------------+----------------------+-------------------|
| [x] | =amplify-user= | AKIAIUOQZESWPXCPGBUA | =***...= Show     |

** Setup Access Keys

   #+CINDEX:access key ID
   #+CINDEX:secret access key
   [01:16] Copy the =access key ID= to your clipboard, jump back to the
   command-line and paste it into the prompt.  Do the same with the =secret
   access key=. [fn:6]

   #+CINDEX:profile name, set
   #+CINDEX:CLI, configured
   #+CINDEX:AWS Amplify project, initialize
   #+CINDEX:initialize AWS Amplify project
   [01:29] Here we can set a =profile name=. I'll give the =profile name= a
   name of ~amplify-egghead-cli-user~.  Now the CLI has been configured and
   we're ready to begin initializing new AWS Amplify projects.

* Create & Configure an AWS Amplify Project with a React Application

  #+CINDEX:React application, create new
  #+CINDEX:AWS Amplify project, create new
  #+CINDEX:React application, configure
  #+CINDEX:configure, React application
  #+CINDEX:AWS services
  In this lesson we’ll create a new React application, create a new
  AWS Amplify project, & configure the React application to begin
  working with Amplify & AWS services.

  - New React Application
  - New AWS Amplify project
  - Configure Application to Work with AWS Amplify Services

** Create A New React Application

[00:01] Now that we've installed and configured the CLI, let's create a new
React application, and then initialize a new Amplify project within the React
application.

#+CINDEX:@command{create-react-app}
#+CINDEX:React application, create new
[00:14] To do so, we'll use {{{command(create-react-app)}}}[fn:7] to create a
[[https://reactjs.org/docs/create-a-new-react-app.html][new React application]] called ~my-amplify-app~.  Once the new React application
has been created, let's change into the new directory.
: create-react-app my-amplify-app

*** ~create-react-app~ my-amplify-app

#+BEGIN_EXAMPLE
Creating a new React app in /Users/pine/Dev/Programming/WebDev/React/React-AWS-Amplify/my-amplify-app.

Installing packages. This might take a couple of minutes.
Installing react, react-dom, and react-scripts...

yarn add v1.13.0
[1/4] 🔍  Resolving packages...
[2/4] 🚚  Fetching packages...
[3/4] 🔗  Linking dependencies...
warning "react-scripts > pnp-webpack-plugin > ts-pnp@1.0.0" has unmet peer dependency "typescript@*".
[4/4] 🔨  Building fresh packages...
success Saved lockfile.
success Saved 4 new dependencies.
info Direct dependencies
├─ react-dom@16.8.3
├─ react-scripts@2.1.5
└─ react@16.8.3
info All dependencies
├─ react-dev-utils@7.0.3
├─ react-dom@16.8.3
├─ react-scripts@2.1.5
└─ react@16.8.3
   Done in 19.71s.

Success! Created my-amplify-app at /Users/pine/Dev/Programming/WebDev/React/React-AWS-Amplify/my-amplify-app
Inside that directory, you can run several commands:


  yarn start
    Starts the development server.

  yarn build
    Bundles the app into static files for production.

  yarn test
    Starts the test runner.

  yarn eject
    Removes this tool and copies build dependencies, configuration files
    and scripts into the app directory. If you do this, you can’t go back!

We suggest that you begin by typing:

  cd my-amplify-app
  yarn start

Happy hacking!

$ tree
├── my-amplify-app
│   ├── README.md
│   ├── node_modules
│   ├── package.json
│   ├── public
│   ├── src
│   └── yarn.lock
#+END_EXAMPLE

*** Start ~my-amplify-app~

: cd my-amplify-app
: yarn start

#+BEGIN_EXAMPLE
Compiled successfully!

You can now view my-amplify-app in the browser.

  Local:            http://localhost:3000/
  On Your Network:  http://10.0.0.5:3000/

Note that the development build is not optimized.
To create a production build, use yarn build.
#+END_EXAMPLE

** Initialize A New Amplify Project

#+CINDEX:@command{amplify init}
#+CINDEX:Amplify project, initialize
#+CINDEX:initialize, Amplify project
#+CINDEX:options, Amplify project
#+CINDEX:editor, default
#+CINDEX:default editor, Amplify project
#+CINDEX:JavaScript, app type
#+CINDEX:app, JavaScript
#+CINDEX:React, framework type
#+CINDEX:framework, React
[00:31] From within the new directory, we'll run {{{command(amplify init)}}}
to [[https://aws-amplify.github.io/docs/js/start][initialize]] a new [[https://www.amplify.com/][Amplify]] project.  We'll then be prompted for a few
options.  For the default editor, I'll choose Visual Studio code.  For the
/type of app/ we're building, we can choose =JavaScript=.  For the
/framework/ we're using, we can choose =React=.

#+CINDEX:directories, source, distribution
#+CINDEX:build command
#+CINDEX:start command
#+CINDEX:commands, build, start
[00:49] The source directory can be left as ~source~.  The distribution
directory, ~build~.  The {{{command(build)}}} command can be left as
~build~.  The {{{command(start)}}} command can be left as ~start~.

#+CINDEX:AWS profile, choose
[01:04] Next, we're given the option to choose an AWS
profile.  Here, we can choose the profile that we created when we
configured this CLI.

#+CINDEX:Amplify project, initialized
#+CINDEX:rc file, Amplify
#+CINDEX:@file{.amplify} rc file
#+CINDEX:Amplify folder
#+CINDEX:folder, Amplify
#+CINDEX:root directory
[01:18] Now, our Amplify project has been initialized.  We should now see a
{{{file(.amplifyrc)}}} file[fn:15], as well as an {{{file(amplify)}}} folder, in
our root directory.

*** Amplify Initialization
#+BEGIN_EXAMPLE
$ amplify init
Note: It is recommended to run this command from the root of your app directory
? Enter a name for the project my-amplify-app
? Enter a name for the environment ampenv
? Choose your default editor: Emacs (via Terminal, Mac OS only)
? Choose the type of app that you're building javascript
Please tell us about your project
? What javascript framework are you using react
? Source Directory Path:  src
? Distribution Directory Path: build
? Build Command:  npm run-script build
? Start Command: npm run-script start
Using default provider  awscloudformation

For more information on AWS Profiles, see:
https://docs.aws.amazon.com/cli/latest/userguide/cli-multiple-profiles.html

? Do you want to use an AWS profile? Yes
? Please choose the profile you want to use amplify-cli-profile
⠹ Initializing project in the cloud...

CREATE_IN_PROGRESS DeploymentBucket              AWS::S3::Bucket            Mon Feb 25 2019 11:15:52 GMT-0800 (Pacific Standard Time) Resource creation Initiated
CREATE_IN_PROGRESS AuthRole                      AWS::IAM::Role             Mon Feb 25 2019 11:15:51 GMT-0800 (Pacific Standard Time) Resource creation Initiated
CREATE_IN_PROGRESS UnauthRole                    AWS::IAM::Role             Mon Feb 25 2019 11:15:51 GMT-0800 (Pacific Standard Time) Resource creation Initiated
CREATE_IN_PROGRESS AuthRole                      AWS::IAM::Role             Mon Feb 25 2019 11:15:51 GMT-0800 (Pacific Standard Time)
CREATE_IN_PROGRESS DeploymentBucket              AWS::S3::Bucket            Mon Feb 25 2019 11:15:50 GMT-0800 (Pacific Standard Time)
CREATE_IN_PROGRESS UnauthRole                    AWS::IAM::Role             Mon Feb 25 2019 11:15:50 GMT-0800 (Pacific Standard Time)
CREATE_IN_PROGRESS my-amplify-app-20190225111546 AWS::CloudFormation::Stack Mon Feb 25 2019 11:15:47 GMT-0800 (Pacific Standard Time) User Initiated
⠴ Initializing project in the cloud...

CREATE_COMPLETE DeploymentBucket AWS::S3::Bucket Mon Feb 25 2019 11:16:13 GMT-0800 (Pacific Standard Time)
CREATE_COMPLETE AuthRole         AWS::IAM::Role  Mon Feb 25 2019 11:16:08 GMT-0800 (Pacific Standard Time)
CREATE_COMPLETE UnauthRole       AWS::IAM::Role  Mon Feb 25 2019 11:16:08 GMT-0800 (Pacific Standard Time)
✔ Successfully created initial AWS cloud resources for deployments.
✔ Initialized provider successfully.
Initialized your environment successfully.

Your project has been successfully initialized and connected to the cloud!

Some next steps:
"amplify status" will show you what you've added already and if it's locally configured or deployed
"amplify <category> add" will allow you to add features like user login or a backend API
"amplify push" will build all your local backend resources and provision it in the cloud
"amplify publish" will build all your local backend and frontend resources (if you have hosting category added) and provision it in the cloud

Pro tip:
Try "amplify add api" to create a backend API and then "amplify publish" to deploy everything
#+END_EXAMPLE

*** Results of Amplify Initialization

#+BEGIN_EXAMPLE
$ amplify status

Current Environment: ampenv

| Category | Resource name | Operation | Provider plugin |
| -------- | ------------- | --------- | --------------- |

$ ls -A
.gitignore   README.md    amplify      node_modules package.json public       src          yarn.lock

$ tree amplify
amplify
├── #current-cloud-backend
│   └── amplify-meta.json
├── backend
│   ├── amplify-meta.json
│   └── backend-config.json
└── team-provider-info.json

2 directories, 4 files

$ cat package.json
{
  "name": "my-amplify-app",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "react": "^16.8.3",
    "react-dom": "^16.8.3",
    "react-scripts": "2.1.5"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": "react-app"
  },
  "browserslist": [
    ">0.2%",
    "not dead",
    "not ie <= 11",
    "not op_mini all"
  ]
}
#+END_EXAMPLE

** Install Client Libraries

#+CINDEX:client libraries, install
#+CINDEX:install client libraries
[01:29] The last thing we need to do is install the AWS Amplify and
AWS Amplify React Client Libraries into our React application.

#+CINDEX:@command{npm}
#+CINDEX:@command{yarn}
#+CINDEX:@code{aws-amplify} client library
#+CINDEX:@code{aws-amplify-react} client library
[01:39] To do so, we can either use {{{command(npm)}}} or
{{{command(yarn)}}} to add ~AWS Amplify~ and ~AWS Amplify React~.
: yarn add aws-amplify aws-amplify-react

[01:53] Now, the React app has been configured, the Amplify project
has been created, and we're ready to begin adding new features.

*** AWS Amplify and AWS Amplify React

#+BEGIN_EXAMPLE
$ yarn add aws-amplify aws-amplify-react
yarn add v1.13.0
[1/4] 🔍  Resolving packages...
[2/4] 🚚  Fetching packages...
[3/4] 🔗  Linking dependencies...
warning "react-scripts > pnp-webpack-plugin > ts-pnp@1.0.0" has unmet peer dependency "typescript@*".
[4/4] 🔨  Building fresh packages...
success Saved lockfile.
success Saved 26 new dependencies.
info Direct dependencies
├─ aws-amplify-react@2.3.0
├─ aws-amplify@1.1.19
├─ react-dom@16.8.3
└─ react@16.8.3
info All dependencies
├─ @aws-amplify/analytics@1.2.10
├─ @aws-amplify/api@1.0.26
├─ @aws-amplify/interactions@1.0.25
├─ @aws-amplify/pubsub@1.0.22
├─ @aws-amplify/storage@1.0.25
├─ @aws-amplify/ui@1.0.15
├─ @aws-amplify/xr@0.1.12
├─ amazon-cognito-auth-js@1.2.4
├─ amazon-cognito-identity-js@3.0.7
├─ aws-amplify-react@2.3.0
├─ aws-amplify@1.1.19
├─ aws-sdk@2.329.0
├─ axios@0.17.1
├─ crypto-js@3.1.9-1
├─ events@1.1.1
├─ follow-redirects@1.7.0
├─ graphql@0.13.0
├─ ieee754@1.1.8
├─ iterall@1.1.4
├─ jmespath@0.15.0
├─ qr.js@0.0.0
├─ qrcode.react@0.8.0
├─ react-dom@16.8.3
├─ react@16.8.3
├─ xml2js@0.4.19
└─ xmlbuilder@9.0.7
✨  Done in 7.75s.

$ cat package.json
{
  "name": "my-amplify-app",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "aws-amplify": "^1.1.19",
    "aws-amplify-react": "^2.3.0",
    "react": "^16.8.3",
    "react-dom": "^16.8.3",
    "react-scripts": "2.1.5"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": "react-app"
  },
  "browserslist": [
    ">0.2%",
    "not dead",
    "not ie <= 11",
    "not op_mini all"
  ]
}
#+END_EXAMPLE

* Use the AWS Amplify ~withAuthenticator~ HOC to Implement a React User Authorization Flow

#+CINDEX:user authentication flow
#+CINDEX:user authentication, enable
#+CINDEX:Amazon Cognito
#+CINDEX:@code{withAuthenticator} HOC
#+CINDEX:sign-up flow, create
#+CINDEX:sign-in flow, create
In this lesson we’ll enable *user authentication* ([[https://aws.amazon.com/cognito/][Amazon Cognito]]) in
the existing AWS Amplify project, then use the ~withAuthenticator~
/higher order component/ [fn:9] from AWS Amplify [fn:8] to quickly add a
preconfigured sign up and sign in flow.

- enable Amazon Cognito User Authentication in our project
- add ~withAuthenticator~ HOC for sign-up and sign-in flows

** Add Cognito Authentication Service

#+CINDEX:authentication, add service
#+CINDEX:add new service, using Amplify
#+CINDEX:Amplify add new service using
#+CINDEX:@command{amplify add}
#+CINDEX:service, @code{auth}
#+CINDEX:@code{auth} service
[00:02] The first /service/ that we're going to add is *authentication*.

To add a new /service/ using Amplify, we can run {{{command(amplify add)}}}
with the name of the service.  The service name that we're going to be adding
is ~auth~, so we can run {{{command(amplify add auth)}}}.  See [[https://aws-amplify.github.io/docs/js/authentication][Docs
Authentication]].
: amplify add auth

#+CINDEX:default authentication and security configuration
#+CINDEX:configuration, default authentication and security
#+CINDEX:authentication
#+CINDEX:security
#+CINDEX:@command{amplify push}
#+CINDEX:push configuration into account
#+CINDEX:provision new resources
#+CINDEX:resources, provision new
#+CINDEX:resources, create
[00:16] Here, we'll be asked if we would like to use the /default
authentication and security configuration/.  We'll choose =yes=.  Now the new
configuration has been created in our project.  [[*amplify add auth]]

We'll run {{{command(amplify push)}}} to push the new configuration into our
account and create and provision the new resources. [[*amplify push]]
: amplify push

#+CINDEX:create new authentication service
#+CINDEX:authentication service, create new
[00:36] Next, we'll be prompted and asked if we would like to continue. If you
look at the /operation/, you can see that it is set to =create=.  This means it
will create a /new authentication service/ in our account.  This may take a
couple of minutes to complete.

#+CINDEX:@file{AWS-exports.js}
[00:52] Now that the authentication service has been created, we should be able
to look in our {{{file(src)}}} directory ([[*src directory and aws-exports.js]])
and see a new file that was created for us called {{{file(aws-exports.js)}}}.
This file is created and updated by the CLI, so there's no reason for us to
change it.

[01:07] We will, though, be using it in the next step to configure
our React application with the AWS resources.

*** amplify add auth

#+BEGIN_EXAMPLE
$ amplify add auth
Using service: Cognito, provided by: awscloudformation
 The current configured provider is Amazon Cognito.
 Do you want to use the default authentication and security configuration? Yes, use the default configuration.
Successfully added resource cognito04303ec1 locally

Some next steps:
"amplify push" will build all your local backend resources and provision it in the cloud
"amplify publish" will build all your local backend and frontend resources (if you have hosting category added) and provision it in the cloud
#+END_EXAMPLE

*** amplify push

#+BEGIN_EXAMPLE
$ amplify push

Current Environment: ampenv

| Category | Resource name   | Operation | Provider plugin   |
| -------- | --------------- | --------- | ----------------- |
| Auth     | cognito04303ec1 | Create    | awscloudformation |
? Are you sure you want to continue? Yes
⠦ Updating resources in the cloud. This may take a few minutes...

CREATE_IN_PROGRESS authcognito04303ec1           AWS::CloudFormation::Stack Mon Feb 25 2019 12:08:45 GMT-0800 (Pacific Standard Time) Resource creation Initiated
CREATE_IN_PROGRESS authcognito04303ec1           AWS::CloudFormation::Stack Mon Feb 25 2019 12:08:45 GMT-0800 (Pacific Standard Time)
UPDATE_IN_PROGRESS my-amplify-app-20190225111546 AWS::CloudFormation::Stack Mon Feb 25 2019 12:08:40 GMT-0800 (Pacific Standard Time) User Initiated
⠇ Updating resources in the cloud. This may take a few minutes...

CREATE_IN_PROGRESS my-amplify-app-20190225111546-authcognito04303ec1-68587KB5KYOE AWS::CloudFormation::Stack Mon Feb 25 2019 12:08:45 GMT-0800 (Pacific Standard Time) User Initiated
⠦ Updating resources in the cloud. This may take a few minutes...

CREATE_IN_PROGRESS SNSRole AWS::IAM::Role Mon Feb 25 2019 12:08:53 GMT-0800 (Pacific Standard Time) Resource creation Initiated
CREATE_IN_PROGRESS SNSRole AWS::IAM::Role Mon Feb 25 2019 12:08:52 GMT-0800 (Pacific Standard Time)
⠼ Updating resources in the cloud. This may take a few minutes...

CREATE_COMPLETE SNSRole AWS::IAM::Role Mon Feb 25 2019 12:09:11 GMT-0800 (Pacific Standard Time)
⠹ Updating resources in the cloud. This may take a few minutes...

CREATE_COMPLETE    UserPoolClientWeb AWS::Cognito::UserPoolClient Mon Feb 25 2019 12:09:28 GMT-0800 (Pacific Standard Time)
CREATE_IN_PROGRESS UserPoolClientWeb AWS::Cognito::UserPoolClient Mon Feb 25 2019 12:09:28 GMT-0800 (Pacific Standard Time) Resource creation Initiated
CREATE_COMPLETE    UserPoolClient    AWS::Cognito::UserPoolClient Mon Feb 25 2019 12:09:27 GMT-0800 (Pacific Standard Time)
CREATE_IN_PROGRESS UserPoolClient    AWS::Cognito::UserPoolClient Mon Feb 25 2019 12:09:27 GMT-0800 (Pacific Standard Time) Resource creation Initiated
CREATE_IN_PROGRESS UserPoolClientWeb AWS::Cognito::UserPoolClient Mon Feb 25 2019 12:09:25 GMT-0800 (Pacific Standard Time)
CREATE_IN_PROGRESS UserPoolClient    AWS::Cognito::UserPoolClient Mon Feb 25 2019 12:09:25 GMT-0800 (Pacific Standard Time)
CREATE_COMPLETE    UserPool          AWS::Cognito::UserPool       Mon Feb 25 2019 12:09:20 GMT-0800 (Pacific Standard Time)
CREATE_IN_PROGRESS UserPool          AWS::Cognito::UserPool       Mon Feb 25 2019 12:09:20 GMT-0800 (Pacific Standard Time) Resource creation Initiated
CREATE_IN_PROGRESS UserPool          AWS::Cognito::UserPool       Mon Feb 25 2019 12:09:17 GMT-0800 (Pacific Standard Time)
⠋ Updating resources in the cloud. This may take a few minutes...

CREATE_IN_PROGRESS UserPoolClientRole AWS::IAM::Role Mon Feb 25 2019 12:09:33 GMT-0800 (Pacific Standard Time) Resource creation Initiated
CREATE_IN_PROGRESS UserPoolClientRole AWS::IAM::Role Mon Feb 25 2019 12:09:32 GMT-0800 (Pacific Standard Time)
⠏ Updating resources in the cloud. This may take a few minutes...

CREATE_COMPLETE    UserPoolClientLambda AWS::Lambda::Function Mon Feb 25 2019 12:09:56 GMT-0800 (Pacific Standard Time)
CREATE_IN_PROGRESS UserPoolClientLambda AWS::Lambda::Function Mon Feb 25 2019 12:09:55 GMT-0800 (Pacific Standard Time) Resource creation Initiated
CREATE_IN_PROGRESS UserPoolClientLambda AWS::Lambda::Function Mon Feb 25 2019 12:09:55 GMT-0800 (Pacific Standard Time)
CREATE_COMPLETE    UserPoolClientRole   AWS::IAM::Role        Mon Feb 25 2019 12:09:51 GMT-0800 (Pacific Standard Time)
⠦ Updating resources in the cloud. This may take a few minutes...

CREATE_IN_PROGRESS UserPoolClientLambdaPolicy AWS::IAM::Policy Mon Feb 25 2019 12:10:08 GMT-0800 (Pacific Standard Time) Resource creation Initiated
CREATE_IN_PROGRESS UserPoolClientLambdaPolicy AWS::IAM::Policy Mon Feb 25 2019 12:10:07 GMT-0800 (Pacific Standard Time)
⠴ Updating resources in the cloud. This may take a few minutes...

CREATE_IN_PROGRESS UserPoolClientLogPolicy    AWS::IAM::Policy Mon Feb 25 2019 12:10:22 GMT-0800 (Pacific Standard Time) Resource creation Initiated
CREATE_IN_PROGRESS UserPoolClientLogPolicy    AWS::IAM::Policy Mon Feb 25 2019 12:10:21 GMT-0800 (Pacific Standard Time)
CREATE_COMPLETE    UserPoolClientLambdaPolicy AWS::IAM::Policy Mon Feb 25 2019 12:10:16 GMT-0800 (Pacific Standard Time)
⠹ Updating resources in the cloud. This may take a few minutes...

CREATE_IN_PROGRESS UserPoolClientInputs    Custom::LambdaCallout Mon Feb 25 2019 12:10:38 GMT-0800 (Pacific Standard Time) Resource creation Initiated
CREATE_IN_PROGRESS UserPoolClientInputs    Custom::LambdaCallout Mon Feb 25 2019 12:10:35 GMT-0800 (Pacific Standard Time)
CREATE_COMPLETE    UserPoolClientLogPolicy AWS::IAM::Policy      Mon Feb 25 2019 12:10:31 GMT-0800 (Pacific Standard Time)
⠙ Updating resources in the cloud. This may take a few minutes...

CREATE_IN_PROGRESS IdentityPoolRoleMap  AWS::Cognito::IdentityPoolRoleAttachment Mon Feb 25 2019 12:10:51 GMT-0800 (Pacific Standard Time)
CREATE_COMPLETE    IdentityPool         AWS::Cognito::IdentityPool               Mon Feb 25 2019 12:10:47 GMT-0800 (Pacific Standard Time)
CREATE_IN_PROGRESS IdentityPool         AWS::Cognito::IdentityPool               Mon Feb 25 2019 12:10:46 GMT-0800 (Pacific Standard Time) Resource creation Initiated
CREATE_IN_PROGRESS IdentityPool         AWS::Cognito::IdentityPool               Mon Feb 25 2019 12:10:44 GMT-0800 (Pacific Standard Time)
CREATE_COMPLETE    UserPoolClientInputs Custom::LambdaCallout                    Mon Feb 25 2019 12:10:39 GMT-0800 (Pacific Standard Time)
⠧ Updating resources in the cloud. This may take a few minutes...

UPDATE_COMPLETE                     my-amplify-app-20190225111546 AWS::CloudFormation::Stack Mon Feb 25 2019 12:11:06 GMT-0800 (Pacific Standard Time)
UPDATE_COMPLETE_CLEANUP_IN_PROGRESS my-amplify-app-20190225111546 AWS::CloudFormation::Stack Mon Feb 25 2019 12:11:05 GMT-0800 (Pacific Standard Time)
CREATE_COMPLETE                     authcognito04303ec1           AWS::CloudFormation::Stack Mon Feb 25 2019 12:11:01 GMT-0800 (Pacific Standard Time)
✔ All resources are updated in the cloud
#+END_EXAMPLE

*** src directory and aws-exports.js

#+BEGIN_EXAMPLE
$ tree src
src
├── App.css
├── App.js
├── App.test.js
├── aws-exports.js
├── index.css
├── index.js
├── logo.svg
└── serviceWorker.js

0 directories, 8 files

$ cat src/aws-exports.js
// WARNING: DO NOT EDIT. This file is automatically generated by AWS Amplify. It will be overwritten.

const awsmobile = {
    "aws_project_region": "us-west-2",
    "aws_cognito_identity_pool_id": "us-west-2:fa1cd560-580d-4fc9-bfcb-2c10e19b3cc4",
    "aws_cognito_region": "us-west-2",
    "aws_user_pools_id": "us-west-2_QweWlfgNU",
    "aws_user_pools_web_client_id": "5k79dgm1rvlt773bk9qp4jq99r"
};


export default awsmobile;
#+END_EXAMPLE

** Configure React App with AWS Resources

#+CINDEX:React application, configure with AWS resource
#+CINDEX:AWS resources, configure React app
#+CINDEX:@file{source/index.js}
#+CINDEX:@file{index.js}
#+CINDEX:Amplify, import from AWS Amplify library
#+CINDEX:library, AWS Amplify, import
#+CINDEX:import AWS Amplify library
#+CINDEX:@code{amplify.configure}
To configure our React app with the AWS Amplify resources, we edit
{{{file(src/index.js)}}}.

{{{heading(index.js)}}}

#+NAME:index.js
#+CAPTION:~index.js~ with AWS Amplify and Configuration Imports
#+BEGIN_SRC js -n :eval never :tangle my-amplify-app/src/index.js :noweb tangle
import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import App from './App';
import * as serviceWorker from './serviceWorker';
/* --------------------------------- */
<<aws-amplify and configure imports>>
/* --------------------------------- */

ReactDOM.render(<App />, document.getElementById('root'));

// If you want your app to work offline and load faster, you can change
// unregister() to register() below. Note this comes with some pitfalls.
// Learn more about service workers: http://bit.ly/CRA-PWA
serviceWorker.unregister();
#+END_SRC

{{{heading(Imports into and Configuration of ~index.js~)}}}

Here, we'll

- ~import Amplify~ from the AWS Amplify library, ~aws-amplify~
- ~import config~ from the AWS exports file, [[#aws-exports][~./aws-exports.js~]], below
- and then we'll call ~Amplify.configure(config)~, passing in the ~config~.

#+NAME:aws-amplify and configure imports
#+CAPTION:Amplify Imports and Configuration
#+BEGIN_SRC js -n :eval never
import Amplify from 'aws-amplify';
import config from './aws-exports';
Amplify.configure(config);
#+END_SRC

*** Config from ~aws-exports.js~
:PROPERTIES:
:CUSTOM_ID: aws-exports
:END:

#+BEGIN_SRC js -n :eval no-exports
// WARNING: DO NOT EDIT. This file is automatically generated by AWS Amplify. It will be overwritten.

const awsmobile = {
    "aws_project_region": "us-west-2",
    "aws_cognito_identity_pool_id": "us-west-2:fa1cd560-580d-4fc9-bfcb-2c10e19b3cc4",
    "aws_cognito_region": "us-west-2",
    "aws_user_pools_id": "us-west-2_QweWlfgNU",
    "aws_user_pools_web_client_id": "5k79dgm1rvlt773bk9qp4jq99r"
};
#+END_SRC

** Install Higher Order Component

#+CINDEX:@code{withAuthenticator} higher order component
#+CINDEX:higher order component, @code{withAuthenticator}
#+CINDEX:HOC @code{withAuthenticator}
#+CINDEX:@file{source/app.js}
#+CINDEX:import @file{withAuthenticator} HOC
#+CINDEX:wrap App component with HOC @file{withAuthenticator}
[01:47] Next, we'll edit {{{file(src/App.js)}}}.

{{{heading(Original ~App.js~)}}}

#+NAME:App-hoc
#+CAPTION:Original App.js Wrapped in @code{withAuthenticator} HOC
#+CINDEX:original @file{App.js}
#+BEGIN_SRC js -n :eval never :tangle my-amplify-app/src/App-hoc.js :noweb tangle
import React, { Component } from 'react';
import logo from './logo.svg';
import './App.css';
/* --------------------------------- */
<<import_withAuthenticator>>
/* --------------------------------- */

class App extends Component {
  render() {
    return (
      <div className="App">
        <header className="App-header">
          <img src={logo} className="App-logo" alt="logo" />
          <p>
            Edit <code>src/App.js</code> and save to reload.
          </p>
          <a
            className="App-link"
            href="https://reactjs.org"
            target="_blank"
            rel="noopener noreferrer"
          >
            Learn React
          </a>
        </header>
      </div>
    );
  }
}

// export default App;
/* --------------------------------- */
<<export_withAuthenticator>>
/* --------------------------------- */
#+END_SRC

{{{subheading(Changes to ~App.js~)}}}

Here we'll first:

- import the ~withAuthenticator~ higher order component from the AWS Amplify
  React library, {{{file(aws-amplify-react)}}},

#+NAME:import_withAuthenticator
#+BEGIN_SRC js -n
import { withAuthenticator } from 'aws-amplify-react'
#+END_SRC

- Instead of exporting the App component as a default export, we'll instead
  wrap the app component with the ~withAuthenticator~ higher order
  component:[fn:withAuth] (but see [[*Create Sign-Out]])
  : export default withAuthenticator(App);

#+BEGIN_COMMENT
#+NAME:export_withAuthenticator
#+CAPTION:Export @code{withAuthenticator} Wrapping App.js
#+BEGIN_SRC js -n :eval never
export default withAuthenticator(App);
#+END_SRC
#+END_COMMENT

** Test the Application for User Authentication

#+CINDEX:test application
#+CINDEX:@command{run npm start}
#+CINDEX:application, run
#+CINDEX:user authentication flow, app protected by
#+CINDEX:new account, create
[02:24] Now we're ready to test it out.  To start the app, run:
: yarn start

[[shell:(cd my-amplify-app/src && ln -vsf App-hoc.js App.js)]]

Our app should now be protected by Cognito's user authentication flow.  The
first thing we'll do is click {{{key(create account)}}} to create a new
account.

#+NAME:img:cognito-sign-in
#+CAPTION:Cognito Sign In Modal
[[file:img/cognito-sign-in-50.png]]

#+CINDEX:authentication code, in email
#+CINDEX:confirm new account
#+CINDEX:new account, confirm
#+CINDEX:account, sign in
#+CINDEX:sign in, account
[02:57] After the account has been created, you should receive an
authentication code in your email.  To confirm the sign up, paste in
the authentication code from your email.  After you've confirmed
your account, sign into your account.

#+CINDEX:sign in
#+CINDEX:redirected to main app
#+CINDEX:main app, redirected to
#+CINDEX:user session, in local storage
#+CINDEX:local storage, user session
[03:16] After we've signed in, we should be redirected to the main
app. You'll notice that if you refresh the page, the user remains
signed in. This is because the user session is stored in local
storage.

** Create Sign-Out

#+CINDEX:sign-out button, create
#+CINDEX:@file{App.js}
#+CINDEX:@file{withAuthenticator}
#+CINDEX:@code{include-greetings} key
#+CINDEX:key, @code{include-greetings}
[03:28] Next, let's add a {{{key(SIGN OUT)}}} button.  To do so we'll go back
into {{{file(App.js)}}} and pass in a second argument to ~withAuthenticator~.
Here, we'll pass in an object with an ~includeGreetings~ key set to
~true~.[fn:withAuth:You must comment out the other ~withAuthenticator~ code
prior to using this code by uncommenting it.]

#+NAME:export_withAuthenticator
#+BEGIN_SRC js -n :eval never
export default withAuthenticator(App, { includeGreetings: true });
#+END_SRC

#+CINDEX:sign-out button
[03:58] Now when we refresh, we should see a {{{key(SIGN OUT)}}} button at the
top right corner of the page.

#+NAME:img:cognito-sign-out
#+CAPTION:Cognito Sign Out Button
[[file:img/cognito-sign-out.png]]

** View Amplify Services in CLI

#+CINDEX:Amplify services, view enabled
#+CINDEX:enabled Amplify services, view
#+CINDEX:@command{amplify status}
#+CINDEX:resource name
To view enabled Amplify services at any time, we can run {{{command(amplify
status)}}}.  Here, we're given the resource name for the authentication that we
just created.

#+BEGIN_EXAMPLE
$ amplify status

Current Environment: ampenv

| Category | Resource name   | Operation | Provider plugin   |
| -------- | --------------- | --------- | ----------------- |
| Auth     | cognito04303ec1 | No Change | awscloudformation |
#+END_EXAMPLE

** View Cognito Authentication Service in Console

#+CINDEX:Cognito authentication service, view
#+CINDEX:AWS account, Cognito authentication service
#+CINDEX:Cognito dashboard
#+CINDEX:Amazon Cognito user pool
#+CINDEX:dashboard, Cognito
#+CINDEX:@command{manage user pools}
#+CINDEX:user pool
[04:16] To view the Cognito authentication service in your AWS account, open
the AWS console and search for Cognito.  In the Cognito dashboard, click on
{{{key(manage user pools)}}} and then click on the user pool for the
application that we just created.

#+CINDEX:users, view
#+CINDEX:signed-up users, view
[04:32] Here, we can view the settings for the Amazon Cognito user
pool that we've created and also view any of the users that have
signed up.

#+NAME:img:cognito-manage-user-pools
#+CAPTION:Manage User Pools in Cognito
[[file:img/cognito-manage-user-pools-50.png]]

#+NAME:img:cognito-users-and-groups
#+CAPTION: Users and Groups in Cognito
file:img/cognito-users-and-groups-30.png

#+NAME:img:cognito-users
#+CAPTION:Users in Cognito
file:img/cognito-users-50.png

* Manually Sign Up New Users in React with AWS Amplify Auth Class

#+CINDEX:@code{Auth} class
#+CINDEX:create custom user sign-in, sign-up flow
#+CINDEX:sign-in flow, create
#+CINDEX:sign-up flow, create
In this lesson we’ll look at how we can use the ~Auth~ class from the AWS
Amplify JavaScript library [to] directly create a custom user sign-up and
sign-in flow.[fn::Instead of using AWS's custom forms and methods, as was done
in the previous segment.]

{{{heading(Steps for Custom Sign-In Flow)}}}

In {{{file(App.js)}}}:
- Import ~Auth~ from the AWS Amplify library
- add state variables
  - username
  - password
  - email
  - phone_number
  - authenticationCode
- add ~onChange~ handler
- add ~signUp~ and ~confirmSignUp~ class methods
- add two forms for signing up and confirming
- add sign-up button
- add styles

{{{heading(Original ~App.js~)}}}

Here is the origin {{{file(App.js)}}}, with new code added using =noweb=
references in double angle brackets =<<...>>=.

#+CINDEX:original @file{App.js}
#+BEGIN_SRC js -n -r :eval never :tangle my-amplify-app/src/App-custom.js :noweb tangle
import React, { Component } from 'react';
import logo from './logo.svg';
import './App.css';
<<authImport>> (ref:auth)

class App extends Component {
/* --------------------------------- */
  <<state>> (ref:state)
  <<onChange-handler>> (ref:onChange)
  <<signUp>> (ref:signUp)
  <<confirmSignUp>> (ref:confirm)
/* --------------------------------- */

  render() {
    return (
      <div className="App">
        <header className="App-header">
          <img src={logo} className="App-logo" alt="logo" />
          <p>
            Edit <code>src/App.js</code> and save to reload.
          </p>
          <a
            className="App-link"
            href="https://reactjs.org"
            target="_blank"
            rel="noopener noreferrer"
          >
            Learn React
          </a>
        </header>
          <<two-forms>>
      </div>
    );
  }
}

/* --------------------- */
  <<styles>> (ref:styles)
/* --------------------- */

export default App;
#+END_SRC

** Import Authentication Functionality For Sign-Up

#+CINDEX:@command{import auth}
#+CINDEX:@code{auth}, import
#+CINDEX:AWS Amplify library
#+CINDEX:library, Amplify
#+CINDEX:initial state, create
#+CINDEX:state, create initial
#+CINDEX:user, signup
#+CINDEX:user information, add
[00:02] Starting in {{{file(App.js)}}}, the first thing we'll do is [[(auth)][import
~Auth~]], (line [[(auth)]]), from the AWS Amplify library.

#+NAME: authImport
#+CAPTION:Import ~Auth~ Class from the AWS Amplify Library
#+BEGIN_SRC js -n :eval never
import { Auth } from 'aws-amplify';
#+END_SRC

** Add State Members

Next, we'll create some initial state.  We'll need to keep up with the
- username,
- password,
- email,
- phone_number, and
- authenticationCode
- <<step-attribute>>step ([[step][step]])

for the user that is being signed up.

#+NAME:state
#+CAPTION:Class State Members
#+BEGIN_SRC js -n :eval never
state = {
  username: '',
  password: '',
  email: '',
  phone_number: '',
  authenticationCode: '',
  step: 0
}
#+END_SRC

** On-Change Handler for Sign-Up Functionality

#+CINDEX:@code{onChange} handler
#+CINDEX:handler, @code{onChange}
#+CINDEX:text input, handle
#+CINDEX:@code{setState}
#+CINDEX:@code{event.target.name}, set
#+CINDEX:@code{event.target.value}, set
[00:30] Next, we'll need an ~onChange~ handler to handle the user's text
input.  This function will call ~this.setState~, setting the
~event.target.name~ and the ~event.target.value~.

#+NAME:onChange-handler
#+CAPTION:State ~onChange~ Handler
#+BEGIN_SRC js -n :eval never
onChange = e => {
  this.setState({
    [e.target.name]: e.target.value
  })
}
#+END_SRC

** Sign Up and Confirmation Class Methods

#+CINDEX:sign-up, create class method
#+CINDEX:confirm sign-up, create class method
[00:49] We'll next create ~signUp~ and ~confirmSignUp~ class methods.

*** Sign-Up Class Method

#+CINDEX:class method, sign-up
#+CINDEX:async, sign-up method
#+CINDEX:@code{try-catch} block
#+CINDEX:destructure user info
#+CINDEX:@code{auth.signUp}, call
#+CINDEX:call @code{auth.signUp}
#+CINDEX:attributes object
#+CINDEX:successful sign-up
=signUp= will be /async/, so we'll create a ~try-catch~ block.

We'll first destructure from the state the:
- username,
- password,
- email, and
- phone_number


We'll then call ~Auth.signUp~, passing in the =username= and =password= as well
as an ~attributes~ object containing the =email= and the =phone_number=.

If the sign up is successful, we'll console log ``Successfully signed up.''

#+NAME:signUp
#+CAPTION:~signUp~ Class Method
#+BEGIN_SRC js -n :eval never :noweb yes
signUp = async () => {
    const {
        username,
        password,
        email,
        phone_number
    } = this.state;

    try {
        await Auth.signUp({
            username,
            password,
            attributes: {
                email,
                phone_number
            }
        })
        console.log("Successfully signed up!");
        <<toggle-step>>
    } catch (err) {
        console.log("Error signing up: ", err);
    }
}
#+END_SRC

*** Confirm-Sign-Up Class Method

#+CINDEX:@code{confirm sign up}
#+CINDEX:multi-factor authentication
#+CINDEX:authentication, multi-factor
#+CINDEX:destructure user info
#+CINDEX:@code{try-catch} block
#+CINDEX:@code{Auth.confirmSignup}, call
#+CINDEX:call @code{Auth.confirmSignup}
#+CINDEX:user, successful sign-up
[01:57] ~confirmSignUp~ will handle the /multi-factor authentication/, so we'll
destructure both the username and the authentication code from the state.  Here
we'll also set up a =try-catch= block.  We'll call ~Auth.confirmSignUp~,
passing in the =username= and the =authenticationCode=.  If this is successful,
we'll console log ``User successfully confirmed signed up.''

#+NAME:confirmSignUp
#+CAPTION:~confirmSignUp~ Class Method
#+BEGIN_SRC js -n :eval never
confirmSignUp = async () => {
    const {
        username,
        authenticationCode
    } = this.state;

    try {
        await Auth.confirmSignUp(username, authenticationCode);
        console.log("User successfully confirmed sign up!");
    } catch (err) {
        console.log("Error confirming sign up: ", err);
    }
}
#+END_SRC

** Two Forms---Sign-Up and Confirm-Sign-Up

#+CINDEX:forms, for signing up
#+CINDEX:@code{signUp} form
#+CINDEX:@code{confirmSignUp} form
[02:41] This component will contain two forms, one for signing up and one for
confirming the sign up.

1. ~signUp~ form
2. ~confirnmSignUp~ form

#+NAME:two-forms
#+BEGIN_SRC js -n :eval never :noweb no-export
<<signUp-form>>
<<confirmSignUp-form>>
#+END_SRC

*** Sign-Up Form

{{{subheading(step Variable)}}}

#+CINDEX:variable @code{step}
#+CINDEX:@code{step} variable
#+CINDEX:toggle forms
#+CINDEX:@code{render} method
#+CINDEX:@code{state.step}
#+CINDEX:form, sign-up, show
#+CINDEX:sign-up form, show
<<step>>We'll create a variable called ~step~ that we'll use to toggle between
these two forms ([[step-attribute][step-attribute]]).  [03:04] In our ~render~ method we'll check
to see if ~this.state.step~ is equal to zero.  If it is, we'll show the
=signUp= form.

{{{subheading(signUp Inputs)}}}

#+CINDEX:@code{onChange} method, sign-up form
#+CINDEX:properties, name and style
The =signUp= form will contain four inputs, each with an ~onChange~ method, a
=name= property, and a =style= property.

#+CINDEX:placeholder @code{attributes}
#+CINDEX:@code{attributes} placeholder
[03:43] We'll also add a =placeholder= attribute.

{{{subheading(Sign Up Button)}}}

#+CINDEX:sign-up button, create
#+CINDEX:button, create sign-up
Finally, we'll create a sign-up button that will call ~this.signup~ when
clicked.

#+NAME:signUp-form
#+CAPTION:Sign-Up Form
#+BEGIN_SRC js -n :eval never
{
    this.state.step === 0 && (
        <div>
            <input
                onChange={this.onChange}
                name='username'
                style={styles.input}
                placeholder='username'
            />
            <input
                onChange={this.onChange}
                name='password'
                style={styles.input}
                placeholder='password'
            />
            <input
                onChange={this.onChange}
                name='email'
                style={styles.input}
                placeholder='email'
            />
            <input
                onChange={this.onChange}
                name='phone_number'
                style={styles.input}
                placeholder='phone number'
            />
            <button onClick={this.signUp}>
                Sign Up
            </button>
        </div>
    )
}
#+END_SRC

*** Confirm-Sign-Up Form

#+CINDEX:confirm sign-up button, create
#+CINDEX:sign-up button, confirm, create
To create the =confirmSignUp= form, we can just copy and paste the sign-up form
to get started, then make our changes to confirm ~username~ and
~authenticationCode~.

#+CINDEX:confirm sign-up button
#+CINDEX:@code{confirmSignup}, call
#+CINDEX:call @code{confirmSignup}
[04:31] This form will only need two inputs, one for the username
and one for the authentication code.  The button for this form will
call ~this.confirmSignup~.

#+NAME:confirmSignUp-form
#+CAPTION:Confirm Sign-Up Form
#+BEGIN_SRC js -n :eval -never
{
    this.state.step === 1 && (
        <div>
            <input
                placeholder='username'
                onChange={this.onChange}
                name='username'
                style={styles.input}
            />
            <input
                placeholder='authentication code'
                onChange={this.onChange}
                name='authenticationCode'
                style={styles.input}
            />
            <button onClick={this.confirmSignUp}>
                Confirm Sign Up
            </button>
        </div>
    )
}
#+END_SRC

*** Toggle Step and Add Styles

{{{subheading(Toggle step State Member)}}}

#+CINDEX:@code{setState}, call
#+CINDEX:call @code{setState}
#+CINDEX:sign-up, successful, set @code{step}
[04:52] Going back to the =signUp= method, we'll call ~this.setState~, setting
the ~step~ to one if the sign up is successful.

#+NAME:toggle-step
#+CAPTION:Toggle the ~step~ State Member
#+BEGIN_SRC js -n :eval never
this.setState({ step: 1 });
#+END_SRC

{{{subheading(Styles Variable)}}}

#+CINDEX:@code{styles} variable
#+CINDEX:variable @code{styles}
#+CINDEX:input components
#+CINDEX:components, input
Next, we'll scroll to the bottom of the component and we'll add a ~styles~
variable, setting the styles for the input components.

#+NAME:styles
#+CAPTION:Styles Variable
#+BEGIN_SRC js -n :eval never
const styles = {
    input: {
        height: 35, margin: 5
  }
}
#+END_SRC

** Test Sign-Up and Confirm-Sign-Up

#+CINDEX:@command{npm start}, run
#+CINDEX:run @command{npm start}
#+CINDEX:new user sign-up
#+CINDEX:sign-up, new user
#+CINDEX:form, @samp{confirm sign up}
#+CINDEX:@samp{confirm sign up} form
[05:21] To test this out, let's run {{{command(yarn start)}}}.  When we sign
up a new user, we should see ``Successfully signed up'' logged out to the
console.  We should also see the =confirm sign up= form appear on our
screen.

[[file:img/cognito-manual-new-user-50.png]]

: Successfully signed up!

[[file:img/cognito-manual-user-confirm-50.png]]

#+BEGIN_SRC sh :exports none
cd my-amplify-app/src
ln -vsf App-custom.js App.js
#+END_SRC

#+RESULTS:
: App.js -> App-custom.js

#+CINDEX:confirm sign-up
#+CINDEX:sign-up, confirm
[05:52] To confirm sign up, use the username you just created as well as the
authentication code you received in your email and click =confirm sign up=.
If the sign up is successful, you should see ``User successfully signed up''
logged out to the console.

: User successfully confirmed sign up!

*** Make Sure New User Exists in AWS Dashboard

#+CINDEX:user exists, confirm
#+CINDEX:dashboard, AWS
#+CINDEX:AWS dashboard
#+CINDEX:Cognito console
#+CINDEX:console, Cognito
#+CINDEX:new user, look at in console
#+CINDEX:user pools, manage
#+CINDEX:manage user pools
[06:06] To make sure that this user exists, let's jump into the AWS dashboard
and go to the Cognito console to look at the new user.  In the Cognito
dashboard we'll click on =Manage User Pools= and then we'll click on the name
of the user pool for our app.  When we click on =Users and Groups=, we should
now see the new user appear.

[[~/Dev/Programming/WebDev/React/React-AWS-Amplify/img/cognito-manual-user-sign-up-30.png]]

* Create & Interact with an AWS AppSync GraphQL API with AWS Amplify

  - Create GraphQL API
  - Using Amplify CLI
  - To query data from API
  - And perform mutations

  #+CINDEX:GraphQL API, create new
  #+CINDEX:create new GraphQL API
  #+CINDEX:Amplify  CLI
  #+CINDEX:Amplify GraphQL API
  #+CINDEX:query data
  #+CINDEX:data query
  #+CINDEX:render data in app
  #+CINDEX:mutations, perform for client
  In this lesson we’ll create a new [[https://graphql.org/][GraphQL]] API using the Amplify CLI and use
  the [[https://aws-amplify.github.io/docs/js/api][Amplify GraphQL API]] to query data from the new API and render it in our
  app.  We’ll also look at how to perform mutations from the client.

** Create AWS AppSync API using the CLI

{{{subheading(Add Amplify Service API)}}}

#+CINDEX:AppSync API
#+CINDEX:@command{amplify add api}
#+CINDEX:GraphQL service
#+CINDEX:@code{amplifyTodoApp}
[00:01] To create an [[https://docs.aws.amazon.com/appsync/latest/devguide/using-your-api.html][AWS AppSync API]], we can run the command {{{command(amplify
add api)}}}. For the type of service, choose GraphQL. Next, we're prompted to
give the API a name. I'll give mine a name of =amplifyTodoApp=.

#+CINDEX:authorization type
#+CINDEX:GraphQL schema
#+CINDEX:schema, GraphQL
#+CINDEX:guided schema creation
[00:18] For the authorization type, we'll choose =API key=.  When we're asked
if we have an annotated GraphQL schema, we'll choose =No=. If we'd like to have
a guided schema creation, we'll choose =Yes=.

{{{subheading(Edit the Scheme)}}}

#+CINDEX:edit schema
#+CINDEX:todo GraphQL schema
[00:32] For what best describes our project, we're going to choose a single
object with fields. Next, we're given an option to go ahead and edit the
schema. Choose =Yes=. We're given an example todo GraphQL schema. We'll take
the existing schema and add a new property of completed and then save the file.

{{{subheading(Push the API Resource)}}}

#+CINDEX:@command{amplify push}
[00:53] Once the file's been saved, jump back to the command line and press
{{{key(Enter)}}}.  Now the resources have been saved locally and we can run
{{{command(amplify push)}}} to create the resource in our account.

{{{subheading(Use the Console to View the API)}}}

#+CINDEX:AWS AppSync
[01:13] Once {{{command(amplify push)}}} has successfully completed, open the
AWS console. From the AWS console, search for =AWS AppSync= so we can go
ahead and take a look at the new API that we just created.

#+CINDEX:dashboard, API
#+CINDEX:Schema, dashboard
[01:34] In the API dashboard, you can click on =Schema= to take a look at the
schema that's been auto-generated for us.

** Execute Queries and Mutations

{{{subheading(Create a Mutation {{{samp(create)}}})}}}

#+CINDEX:Query, queries
#+CINDEX:mutations
#+CINDEX:documentation, API
#+CINDEX:API documentation
#+CINDEX:Docs link
[01:48] Next, click on =Query= so we can begin executing queries and
mutations against the API. The first thing we'd like to do is create a new
=todo=. We'll create a mutation called =create=. To view the API
documentation, you can click on the Docs link on the right side of the
screen.

#+CINDEX:mutations
#+CINDEX:@code{createTodo}
#+CINDEX:@code{updateTodo}
#+CINDEX:@code{deleteTodo}
[02:03] When we click on =Mutations=, we see that we have three different
types of mutations,
- ~createTodo~,
- ~updateTodo~, and
- ~deleteTodo~. 


~createTodo~ takes an input with a =name=, =description= and =completed=
properties.

{{{subheading(Execute the Mutation)}}}

#+CINDEX:mutation, execute
#+CINDEX:Play button
[02:34] To execute the mutation, we can click on the orange {{{key(Play)}}}
button.

{{{subheading(Perform a Query)}}}

#+CINDEX:query, perform
#+CINDEX:@code{listTodos} query
[02:49] Now that we've created a couple of items, let's perform a query. We'll
perform the ~listTodos~ query that returns an ~items~ array. We'll then return
the ID, the name, the description, and the completed values for each todo in
the array.

** Query for Data from our React App

#+CINDEX:data query
#+CINDEX:query for data
#+CINDEX:@code{graphqlOperation}
#+CINDEX:Amplify
#+CINDEX:@code{listTodos} query
[03:27] Now that we've populated our API with a little bit of data, let's
query for the data from our React app.

1. The first thing we'll do is that we'll {{{command(import)}}} API and
   ~graphqlOperation~ from AWS Amplify.

2. Next, we'll define our ~listTodos~ query to return the =id=, the =name=, the
   =description=, and the =completed= properties for every item in the =todos=
   array.

    #+CINDEX:initial state
    #+CINDEX:@code{componentDidMount} life cycle method
    #+CINDEX:life cycle method, @code{componentDidMount}
    #+CINDEX:@code{api.graphql}
    #+CINDEX:@code{listTodos}
    #+CINDEX:@code{graphqlOperation}
3. [04:03] In the class, we'll create some *initial state* to hold the =todos=
   array and set it as an empty array.

4. We'll create a ~componentDidMount~ life cycle method where we'll call
   ~API.graphql~, passing in the ~listTodos~ ~graphqlOperation~.

   #+CINDEX:@code{setState}, call
   #+CINDEX:render method
   #+CINDEX:map, over array
   #+CINDEX:array, map over
5. [04:37] Once the data's returned from our API, we'll call ~this.setState~,
   updating the ~todos~ array with the data returned from the API.

6. In the render method, we'll map over the ~todos~ array, showing the ~todo~
   name and the ~todo~ description.

** Run the Application

#+CINDEX:app, run
#+CINDEX:run app
#+CINDEX:@command{npm start}
[05:14] Now we're ready to run the app. I'll go ahead and open the terminal and
run {{{command(npm start)}}}. If everything is working correctly, we should see
the =todos= on our screen.

* Create & Interact with a Serverless REST API with AWS Lambda from React

  - Create a Lambda function
  - Use AWS Amplify
  - To interact with the Lambda function
  - From a React application

  #+CINDEX:Lambda function, create
  #+CINDEX:Amplify, interact with Lambda function
  #+CINDEX:microservices
  In this lesson we’ll learn how to create a Lambda function and use AWS
  Amplify to interact with the Lambda function from a React app.  {{{dfn(Lambda
  functions)}}} allow us to easily create one-off functionality or interact
  with microservices. We’ll use the Lambda function to translate text from
  English to Spanish.

** Add a REST API Using a Lambda Function

   #+CINDEX:REST API
   #+CINDEX:AWS Lambda function
   #+CINDEX:Lambda function, AWS
   #+CINDEX:@command{amplify add} command
   #+CINDEX:service type, @samp{rest}
   #+CINDEX:@samp{PeopleAPI}
   [00:02] To add a REST API using a AWS Lambda function, we can run the
   ~amplify add~ API command. For the type of service, we'll choose =rest=. The
   API that we'll be creating will be fetching a list of people. We'll call the
   API =PeopleAPI=. For the path, we'll give it a path of ~/people~.

   #+CINDEX:data source, Lambda function
   #+CINDEX:Lambda function, create new
   #+CINDEX:@code{peoplefunction}
   #+CINDEX:Lambda function, name
   #+CINDEX:function template
   #+CINDEX:Serverless Express function
   [00:26] For the Lambda function data source, we'll create a new Lambda
   function. Next, we're asked for a label for the Lambda function. We'll call
   this =peoplefunction=. For the name of the Lambda function, we'll also call
   it =peoplefunction=. For the function template that we'd like to use, we'll
   use a Serverless Express function.

   #+CINDEX:@file{app.js}, open for editing
   [00:47] Next, we'll be asked if we'd like to edit the local function
   now. We'll choose yes. This should open up
   {{{file(amplify/backend/function/peoplefunction/source/app.js)}}} in our
   text editor.

   #+CINDEX:@code{app.get/people}
   #+CINDEX:@code{/people} route
   #+CINDEX:@code{people} array, create
   #+CINDEX:array, create as @code{people}
   #+CINDEX:data, hard-code
   [01:01] In ~App.js~, we'll see the code for our Lambda function. We'll
   scroll down until we see ~app.get/people~. Right now, ~/people~ is returning
   an object with the ~success~ property and a URL. We'll go ahead and create a
   new array called ~people~ and hard-code some data.

   #+CINDEX:response, update to return @code{people} array
   #+CINDEX:API access, restrict
   #+CINDEX:authentication enabled
   #+CINDEX:authenticated users read access
   #+CINDEX:access, authenticated users
   #+CINDEX:read access, authenticated users
   [01:35] Next, we'll update the response to return the array of
   ~people~. Save this file and drop back to the command line. We're next asked
   if we'd like to restrict API access. Since we have authentication enabled,
   we'll choose =yes=. For access, we'll give authenticated users only
   access. For the type of access, we'll choose ~read~.

   #+CINDEX:configuration, local, created
   #+CINDEX:@command{amplify push}
   #+CINDEX:resources, create
   #+CINDEX:@file{App.js}
   #+CINDEX:Amplify, import API from
   #+CINDEX:import API from Amplify
   [02:02] With the local configuration created, we can run ~amplify push~ to
   push the new configuration to our account and create the resources. Once the
   resources have been created, open up ~App.js~. Here, we'll first import API
   from AWS Amplify.

** Code the Lambda Function

   #+CINDEX:initial state, people array
   #+CINDEX:@code{componentDidMount} lifecycle method
   #+CINDEX:@code{api.get}, call
   #+CINDEX:call @code{api.get}
   [02:29] In our class definition, we'll define an initial state of people and
   set it to an empty array. We'll create a ~componentDidMount~ lifecycle
   method that we'll call ~API.get~. Here we'll pass in the name of the API as
   well as the path that we would like to fetch.

   #+CINDEX:data, returned as array of @code{people}
   #+CINDEX:@code{setstate}, call
   #+CINDEX:call @code{setstate}
   [02:54] The data returned from the API will be an object with an array of
   ~people~. When the data is returned from the API, we'll call
   ~this.setstate~, setting the value of people to ~data.people~.

   #+CINDEX:render method
   #+CINDEX:@code{people} array, map over
   #+CINDEX:map over @code{people} array
   [03:16] In our ~render~ method, we'll map over the ~people~ array, showing
   the person's name as well as the hair color for every item in the array.

   #+CINDEX:@command{npm start}, launch app
   #+CINDEX:launch app with @command{npm start}
   [03:31] Now we'll save the file, and we'll run ~npm start~ to launch the
   app.

** Fetch Data From Third Party API

   #+CINDEX:data, rendered to screen on launch
   #+CINDEX:data, fetch from 3rd party API
   #+CINDEX:Axios package, install
   #+CINDEX:HTTP requests, Axios package
   #+CINDEX:@file{source}
   [03:39] If everything is working properly, we should see the data rendered
   to our screen. Right now, our API is only returning hard-coded data. Let's
   update the API to fetch data from a third-party API. To do so, we're going
   to need to install the Axios package to send HTTP requests. Change into
   ~amplify/backend/function/peoplefunction/source~.

   #+CINDEX:Axios package, install
   #+CINDEX:@code{require axios}
   [04:06] From within this directory, we'll go ahead and install the Axios
   package. We'll next open ~App.js~ from the
   ~backend/function/peoplefunction/source~ folder. Here, we'll first ~require
   Axios~ from the Axios package.

   #+CINDEX:@code{axios.get}
   #+CINDEX:Star Wars API
   #+CINDEX:promise, from Axios
   #+CINDEX:JSON object, with error from Axios
   [04:38] We'll then call Axios.get, passing in the URL for the open source
   Star Wars API. Axios will return a promise. We'll set a ~.then~ and a
   ~.catch~ function. If there's an error, we'll return a JSON object
   containing an error property and setting people to null.

  #+CINDEX:@code{people} variable
  #+CINDEX:variable @code{people}
  #+CINDEX:JSON object
  #+CINDEX:@code{people} array
  [05:10] If it's successful, we'll go ahead and create a new variable called
  ~people~, setting it to ~response.data.results~. We'll then return a JSON
  object with an error property set to null along with the ~people~ array.

  #+CINDEX:@command{amplify push}, changes to Lambda function
  [05:32] Since we've made changes to our Lambda function, we're going to need
  to run ~amplify push~ again.

  #+CINDEX:@command{npm start}, restart React app
  #+CINDEX:data returned from Star Wars API
  #+CINDEX:Star Wars API, data returned from
  [05:43] Once the resources have been updated in your account, we'll
  run ~npm start~ to restart the React app. When the app loads, we should
  now see the data being returned from the Star Wars API.

* Store Data in Amazon S3 with React

  - Amazon S3
  - Store and retrieve items in the cloud
  - Store images in an S3 bucket
  - Using AWS Amplify Storage API

  #+CINDEX:Amazon S3
  #+CINDEX:cloud, store and retrieve items in
  #+CINDEX:images, store
  #+CINDEX:store images
  #+CINDEX:S3 bucket
  #+CINDEX:Amplify Storage API
  #+CINDEX:S3, object storage service
  Amazon S3 offers a way to store and retrieve items in the cloud. In this
  lesson we’ll see how we can easily store images in an S3 bucket using the AWS
  Amplify Storage API. {{{dfn(S3)}}} is object storage built to store and
  retrieve any amount of data from anywhere on the Internet.

** Add Storage Using S3

   #+CINDEX:S3, add storage using
   #+CINDEX:add storage using S3
   #+CINDEX:Amplify @command{add storage} command
   #+CINDEX:@samp{content} storage type
   #+CINDEX:storage type, @samp{content}
   [00:02] To add storage using Amazon S3, we'll run the Amplify ~add storage~
   command. For the type of storage, we'll choose =content=. For the project
   name, you can either use the default or provide a name of your own.

   #+CINDEX:bucket name
   [00:19] Next, we're prompted for a bucket name. If you do use a custom
   bucket name, please be aware that the bucket name needs to be unique.

   #+CINDEX:access to S3 data
   #+CINDEX:access type, @samp{read and write}
   #+CINDEX:@command{amplify push} create S3 resources
   [00:30] For access, we only want to give authorized users access. For the
   type of access, we'll choose =read and write=. Now that the resources have
   been created locally, we'll run ~amplify push~ to create the service in our
   account.

** Code S3 Storage

   #+CINDEX:@file{app.js}, import storage API from Amplify
   #+CINDEX:storage API, Amplify
   #+CINDEX:initial state, create
   [00:49] Once the resource has been successfully created in your account, go
   ahead and open up ~App.js~ in your text editor. The first thing we'll do is
   we'll import the storage API from AWS Amplify. In the class definition,
   we'll create some initial state containing a file URL, a file, and a
   filename.

   #+CINDEX:@code{handleChange} method, file input
   #+CINDEX:@code{file} variable
   #+CINDEX:@code{setstate}, call
   #+CINDEX:call @code{setstate}
   [01:18] We'll create a ~handleChange~ method that will handle the file
   input. We'll save the file data in a variable we'll call ~File~. Then we'll
   call ~this.setstate~, setting the file URL, the file, as well as the
   filename.

   #+CINDEX:@code{saveFile} function, create
   #+CINDEX:save file in S3 bucket
   #+CINDEX:file, save in S3 bucket
   #+CINDEX:@code{storage.put}
   [02:01] We'll next create a function called ~SaveFile~ that will save the
   file in our S3 bucket. ~SaveFile~ will call ~storage.put~, passing in the
   filename as well as the file data.

   #+CINDEX:@command{console.log} file success
   #+CINDEX:@code{setstate}
   [02:20] If this is successful, we'll console.log successfully saved file and
   then call ~this.setstate~, resetting the file URL, the file, and the
   filename. If there's an error, we'll log out the error.

   #+CINDEX:render method
   #+CINDEX:file input, create
   #+CINDEX:@code{onChange} handler
   #+CINDEX:@code{handlechange} handler
   #+CINDEX:@code{onclick} handler
   #+CINDEX:@code{saveFile} handler
   #+CINDEX:handlers, @code{onClick}, @code{onSave}
   [02:51] In our ~render~ method, we'll first create a file input and set the
   ~onchange~ handler to ~this.handlechange~. We'll then create an image with
   the source set to ~this.state.fileURL~. Finally, we'll create a button with
   an ~onclick~ handler set to ~this.SaveFile~.

** Test File Save in S3 Bucket

   #+CINDEX:test file save
   #+CINDEX:@command{npm start}
   #+CINDEX:file upload
   #+CINDEX:file save
   [03:24] Now we can test it out. Open the Terminal and run ~npm start~. Here,
   we should be able to upload and save files. If the save is successful, we
   should see successfully saved file logged out to the console.

** Look at S3 Bucket

   #+CINDEX:bucket, look at
   #+CINDEX:S3 bucket, look at
   #+CINDEX:AWS console
   #+CINDEX:AWS Services, search
   [03:49] Let's take a look at the bucket. To view your S3 buckets, open the
   AWS console and search for S3 in the AWS Services search bar.

   #+CINDEX:bucket, search for
   #+CINDEX:S3 dashboard
   [04:02] In the S3 dashboard, we can now search for the name of the bucket we
   just created. In the public folder, we should now see any images that we
   uploaded.

** Images from S3 Buckets

   #+CINDEX:images, from S3 bucket
   #+CINDEX:S3 bucket, images from
   [04:18] Next, let's look at how to get images from our S3 bucket. To do so,
   click on an image that we've uploaded already and save the name of the file
   to your clipboard.

   #+CINDEX:@file{app.js}
   #+CINDEX:state, remove
   #+CINDEX:@code{componentDidMount} lifecycle method
   #+CINDEX:lifecycle method, @code{componentDidMount}
   #+CINDEX:@code{storage.get}
   #+CINDEX:@code{setstate}
   [04:28] Next, we'll go back to ~App.js~ and make some updates. The first
   thing we'll do is we'll remove all of the state with the exception of the
   file URL. We'll remove the two existing class methods and replace them with
   a ~componentDidMount~ lifecycle method. ~ComponentDidMount~ will call
   ~storage.get~, passing in the name of the image, and then calling
   ~this.setstate~, resetting the value of file URL.

   #+CINDEX:@code{render} method
   #+CINDEX:@command{npm start}
   #+CINDEX:image, render to screen
   [05:08] In our ~render~ method, we can go ahead and delete the input as well
   as the button components. To test it out, open the Terminal and run ~npm
   start~. When the app loads, we should see the image render to our screen.

   #+CINDEX:@code{storage.list}
   #+CINDEX:Storage
   #+CINDEX:list all images on S3 bucket
   #+CINDEX:S3 bucket, list all images
   #+CINDEX:Amplify documentation
   #+CINDEX:documentation, Amplify
   [05:24] Storage also has a ~storage.list~ method that will list out all of
   the images available in the S3 bucket. To learn more, check out the docs at
   [[https://aws-amplify.github.io][Storage Docs]].

* Deploy Your React Application to AWS Using the Amplify CLI

  - Deploy React application
  - To AWS
  - Using Amplify CLI
  - And Amazon S3

  #+CINDEX:deploy React app to AWS
  #+CINDEX:deploy using Amplify CLI, S3
  #+CINDEX:React app, deploy to AWS using Amplify CLI, S3
  In this lesson we learn how to deploy your React application to AWS
  using the Amplify CLI & Amazon S3.

** Add Hosting

   #+CINDEX:add hosting
   #+CINDEX:hosting, add
   #+CINDEX:@command{amplify add hosting}
   #+CINDEX:environment setup
   #+CINDEX:@env{DEV} environment
   #+CINDEX:@env{PROD}
   #+CINDEX:HTTPS, S3
   #+CINDEX:S3 HTTPS
   #+CINDEX:CloudFront distribution
   [00:02] To add hosting, we can run ~amplify add hosting~. For the
   environment setup, we can either choose =DEV= for S3 with HTTP or =PROD= for
   S3 with HTTPS with CloudFront distribution. I'll choose =DEV=.

   #+CINDEX:bucket name
   #+CINDEX:@file{index.html}
   #+CINDEX:@samp{index} doc
   #+CINDEX:@samp{error} doc
   #+CINDEX:doc, @samp{index}, @samp{error}
   [00:16] Next, we're prompted for the bucket name. Give the bucket a unique
   name. For the ~index~ doc and the ~error~ doc, we can choose ~index.html~.

   #+CINDEX:deploy app, from S3 bucket
   #+CINDEX:@command{amplify publish}, from S3 bucket
   #+CINDEX:S3 bucket, deploy
   [00:31] To deploy our new setup, we can run ~amplify publish~. Once the
   deployment is complete, our app should launch in a new window. If we open
   the URL, we see that the app is indeed running from our S3 bucket.

* IAM Identity and Access Management
:PROPERTIES:
:APPENDIX: t
:END:

- [[https://aws.amazon.com/iam/][AWS IAM]]

- [[https://docs.aws.amazon.com/IAM/latest/UserGuide/introduction.html][IAM Documentation]]

#+CINDEX:IAM
#+CINDEX:Identity and Access Management
#+CINDEX:web service, IAM
#+CINDEX:AWS resources, access to
#+CINDEX:AWS services and resources, manage access to
#+CINDEX:AWS users and groups
#+CINDEX:services, manage access to
#+CINDEX:resources, manage access to
#+CINDEX:users, AWS
#+CINDEX:groups, AWS
#+CINDEX:permissions, AWS resources
AWS Identity and Access Management (IAM) is a web service that helps you
securely control access to (manage) AWS /resources/. You use IAM to control who
is /authenticated/ (signed in) and /authorized/ (has permissions) to use
resources.

Using IAM, you can:
- create and manage AWS *users and groups*, and
- use *permissions* to allow and deny their access to AWS resources.


- {{{dfn(Resources)}}} ::
     are objects within a service.  IAM resources include:
  - groups,
  - users,
  - roles, and
  - policies.

#+CINDEX:AWS account
IAM is a feature of your AWS account offered at no additional charge. You will
be charged only for use of other AWS services by your users.

#+CINDEX:IAM, start
#+CINDEX:AWS Management Console
#+CINDEX:Management Console
#+CINDEX:console, management
#+CINDEX:IAM best practices
#+CINDEX:best practices, IAM
#+CINDEX:practices, IAM best
To get started using IAM, or if you have already registered with AWS, go to the
[[https://console.aws.amazon.com/iam/home][AWS Management Console]] and get started with these [[http://docs.aws.amazon.com/IAM/latest/UserGuide/IAMBestPractices.html][IAM Best Practices]].

** AWS Account Root User Identity and Credentials

#+CINDEX:root user identity
#+CINDEX:sign-in identity
#+CINDEX:identity, sign-in
#+CINDEX:identity, root user
#+CINDEX:credetials, root user
#+CINDEX:root user credentials
When you first create an AWS account, you begin with a single sign-in identity
that has complete access to all AWS services and resources in the account.
This identity is called the AWS Account {{{dfn(Root User Identity)}}} and is
accessed by signing in with the /email address/ and /password/ that you used to
create the account.  This combination of your email address and password is
also called your {{{dfn(root user credentials)}}}.  When you use your /root
user credentials/, you have *complete, unrestricted access to all resources in
your AWS account*, including access to your billing information and the ability
to change your password.

{{{heading(Do Not Use Your Root User Credentials)}}}

#+CINDEX:best practice, do not use root
This level of access is necessary when you first set up your account, but you
should not use root user credentials for everyday access.  It is highly
recommended that you do not use the root user for your everyday tasks, even the
administrative ones.  Instead, adhere to the best practice ([[#root_user][best practice]]) of
using the root user only to create your first IAM user.  Then securely lock
away the root user credentials and use them to perform only a few account and
service management tasks.

{{{subheading(Do Not Share Your Root User Credentials)}}}

*We especially recommend that you do not share your root user credentials with
anyone*, because doing so gives them unrestricted access to your account.  /It
is not possible to restrict the permissions that are granted to the root user./

** Users Identities and Permissions

#+CINDEX:user identity
#+CINDEX:user permissions
The following sections explain how you can use IAM to create and manage user
identities and permissions to provide secure, limited access to your AWS
resources, both for yourself and for others who need to work with your AWS
resources.

*** Authentication of Users

#+CINDEX:authentication
#+CINDEX:identity, IAM
#+CINDEX:who is the user
The ``identity'' aspect of AWS Identity and Access Management (IAM) helps you
with the question ``Who is that user?'', often referred to as
{{{dfn(authentication)}}}.

#+CINDEX:users
Instead of sharing your root user credentials with others, you can create
individual {{{dfn(IAM users)}}} within your account that correspond to users in
your organization.  IAM users are not separate accounts; /they are users within
your account/.

#+CINDEX:password, user
#+CINDEX:user password
- Each user can have its own password for access to the AWS Management Console.
  #+CINDEX:access key, user
  #+CINDEX:user access key
- You can also create an individual access key for each user so that the user
  can make programmatic requests to work with resources in your account.
- Users can be applications. An IAM user doesn't have to represent an actual
  person; you can create an IAM user in order to generate an access key for an
  application that runs in your corporate network and needs AWS access.


#+CINDEX:administrative permissions
We recommend that you create an IAM user for yourself and then assign yourself
administrative permissions for your account. You can then sign in as that user
to add more users as needed.

*** Federating Existing Users

#+CINDEX:federate users
#+CINDEX:users, federate
If the users in your organization already have a way to be authenticated, such
as by signing in to your corporate network, you don't have to create separate
IAM users for them. Instead, you can federate those user identities into AWS.

#+CINDEX:temporary AWS security credentials
#+CINDEX:security credentials, temporary
#+CINDEX:credentials, temporary security
#+CINDEX:access resources
#+CINDEX:resources, access
A user can use IAM to get temporary AWS security credentials to access
resources in your AWS account.

#+CINDEX:federation
Federation is particularly useful in these cases:

- Your users already have identities in a corporate directory.

  #+CINDEX:user has Internet identity
  #+CINDEX:Internet identity
  #+CINDEX:identity, Internet
- Your users already have Internet identities.

  #+CINDEX:mobile app
  #+CINDEX:web-based app
  #+CINDEX:app, mobile or web-based
  #+CINDEX:Internet identity provider
  #+CINDEX:Login with Amazon
  #+CINDEX:Amazon
  #+CINDEX:Facebook
  #+CINDEX:Google
  #+CINDEX:OpenID Connect
  #+CINDEX:OIDC
  #+CINDEX:federation, access to AWS
  #+CINDEX:access to AWS using federation
  If you are creating a mobile app or web-based app that can let users identify
  themselves through an Internet identity provider like Login with Amazon,
  Facebook, Google, or any OpenID Connect (OIDC) compatible identity provider,
  the app can use federation to access AWS.

  #+CINDEX:web identity federation
  For more information, see [[https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_oidc.html][About Web Identity Federation]].

  #+CINDEX:Amazon Cognito
  To use identity federation with Internet identity providers, we recommend you
  use [[https://docs.aws.amazon.com/cognito/devguide/][Amazon Cognito]].

*** Authorization---Access Management & Permissions and Policies

#+CINDEX:authorization
#+CINDEX:access management portion
#+CINDEX:principal entity
The access management portion of AWS Identity and Access Management (IAM) helps
you define what a principal entity is allowed to do in an account.

#+CINDEX:principal entity
#+CINDEX:authenticated entity
#+CINDEX:user
#+CINDEX:role
#+CINDEX:authorization, definition
- A {{{dfn(principal entity)}}} is /a person or application that is
  authenticated using an IAM entity/ (user or role).
- Access management is often referred to as {{{dfn(authorization)}}}.


#+CINDEX:policies
#+CINDEX:identities, attaching policies
#+CINDEX:identities: users, groups, roles
#+CINDEX:resources, attching policies
#+CINDEX:manage access in AWS
You manage access in AWS by creating *policies* and attaching them to IAM
*identities* (/users, groups of users, or roles/) or AWS /resources/.

#+CINDEX:policy, definition
- A {{{dfn(policy)}}} is an object in AWS that, when associated with an
  identity or resource, defines their permissions.
- AWS evaluates these policies when a principal uses an IAM entity (user or
  role) to make a request.
- Permissions in the policies determine whether the request is allowed or
  denied.
- Most policies are stored in AWS as JSON documents.


For more information about policy types and uses, see [[https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html][Policies and Permissions]].

**** Policies and Accounts

#+CINDEX:single account
#+CINDEX:account, single
#+CINDEX:policies, single account
- If you manage a single account in AWS, then you define the permissions within
  that account using policies.

  #+CINDEX:multiple accounts
  #+CINDEX:accounts, multiple
- If you manage permissions across multiple accounts, it is more difficult to
  manage permissions for your users.

  #+CINDEX:roles
  #+CINDEX:resource-based policies
  #+CINDEX:access control lists
  #+CINDEX:ACLs
  #+CINDEX:cross-account permissions
  You can use IAM roles, resource-based policies, or access control lists
  (ACLs) for cross-account permissions.

  #+CINDEX:AWS Organizations service
  #+CINDEX:Organization service
- However, if you own multiple accounts, we instead recommend using the AWS
  Organizations service to help you manage those permissions.  For more
  information, see [[https://docs.aws.amazon.com/organizations/latest/userguide/orgs_introduction.html][What is AWS Organizations]]?


**** Policies and Users

#+CINDEX:users
#+CINDEX:identities, users
- IAM users are identities in the service.

- When you create an IAM user, they can't access anything in your account until
  you give them permission.

  #+CINDEX:permissionsm give
  #+CINDEX:identity-based policy
  #+CINDEX:policy, identity-based
  #+CINDEX:policy, attached to user or group
- You give permissions to a user by creating an identity-based policy, which is
  a policy that is attached to the user or a group to which the user belongs.

  #+CINDEX:JSON policy example
  #+CINDEX:example, JSON policy for user
- The following example shows a JSON policy that allows the user to perform all
  Amazon DynamoDB actions (~dynamodb:*~) on the Books table in the
  ~123456789012~ account within the =us-east-2 Region=.

#+BEGIN_EXAMPLE
{
  "Version": "2012-10-17",
  "Statement": {
    "Effect": "Allow",
    "Action": "dynamodb:*",
    "Resource": "arn:aws:dynamodb:us-east-2:123456789012:table/Books"
  }
}
#+END_EXAMPLE

- After you attach this policy to your IAM user, the user only has those
  DynamoDB permissions. Most users have multiple policies that together
  represent the permissions for that user.

- Actions or resources that are not explicitly allowed are denied by default.

  For example, if the preceding policy is the only policy that is attached to a
  user, then that user is allowed to only perform DynamoDB actions on the Books
  table. Actions on all other tables are prohibited.  Similarly, the user is
  not allowed to perform any actions in Amazon EC2, Amazon S3, or in any other
  AWS service.

{{{subheading(Policy Summary Tables)}}}

  #+CINDEX:policy summary tables, definition
- The IAM console includes {{{dfn(policy summary tables)}}} that describe the
  access level, resources, and conditions that are allowed or denied for each
  service in a policy.  Policies are summarized in three tables:

  1. the *policy summary*; the policy summary table includes a list of
     services; choose a service there to see the /service summary/.

  2. the *service summary*; the summary table includes a list of the actions
     and associated permissions for the chosen service.  You can choose an
     action from that table to view the /action summary/.

  3. the *action summary*; this table includes a list of resources and
     conditions for the chosen action.


#+CINDEX:Users page
#+CINDEX:policy summaries, view
#+CINDEX:Policies page
#+CINDEX:managed policies
You can view policy summaries on the Users page for all policies (managed and
inline) that are attached to that user. View summaries on the Policies page for
all managed policies.

#+CINDEX:JSON document, for policy
#+CINDEX:policy JSON document
You can also view the JSON document for the policy.

**** Policies and Groups

#+CINDEX:groups, policies attached to
#+CINDEX:policies attached to groups
- You can organize IAM users into IAM groups and attach a policy to a group.

- In that case, individual users still have their own credentials, but all the
  users in a group have the permissions that are attached to the group.

  #+CINDEX:Best Practices, groups and policies
- Use groups for easier permissions management, and to follow our IAM Best
  Practices.

  #+CINDEX:policies, multiple
- Users or groups can have multiple policies attached to them that grant
  different permissions. In that case, the users' permissions are calculated
  based on the combination of policies. But the basic principle still applies:
  If the user has not been granted an explicit permission for an action and a
  resource, the user does not have those permissions.

**** Federated Users and Roles

Federated users don't have permanent identities in your AWS account the way
that IAM users do.

#+CINDEX:role
#+CINDEX:permissionsm, assigned to role
- To assign permissions to federated users, you can create an entity referred
  to as a role and define permissions for the role.

  #+CINDEX:federated user, associated with role
  #+CINDEX:role and federated user
- When a federated user signs in to AWS, the user is associated with the role
  and is granted the permissions that are defined in the role.

- For more information, see [[https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create_for-idp.html][Creating a Role for a Third-Party Identity Provider
  (Federation)]].

**** Identity-based and Resource-based Policies

#+CINDEX:identity-based policies
#+CINDEX:policies, identity-based
- *Identity-based policies* are permissions policies that you attach to an IAM
  identity, such as an IAM user, group, or role.
- Identity-based policies control what actions the identity can perform, on
  which resources, and under what conditions. Identity-based policies can be
  further categorized:

  #+CINDEX:managed policies
  #+ATTR_TEXINFO: :indic b
  - Managed policies ::
       Standalone identity-based policies that you can attach to multiple
       users, groups, and roles in your AWS account.  You can use two types of
       managed policies:

       #+CINDEX:AWS managed policies
       #+CINDEX:managed policies, AWS
    1. AWS managed policies---Managed policies that are created and managed by
       AWS.  *If you are new to using policies, we recommend that you start by
       using AWS managed policies.*

       #+CINDEX:customer managed policies
       #+CINDEX:managed policies, customer
    2. Customer managed policies---Managed policies that you create and manage
       in your AWS account.  Customer managed policies provide more precise
       control over your policies than AWS managed policies. You can create and
       edit an IAM policy in the visual editor or by creating the JSON policy
       document directly.

       For more information, see [[https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_create.html][Creating IAM Policies and Editing IAM
       Policies]].

    #+CINDEX:inline policies
  - Inline policies ::
       Policies that you create and manage and that are embedded directly into
       a single user, group, or role.  *In most cases, we don't recommend using
       inline policies.*

  #+CINDEX:resource-based policies
  #+CINDEX:policites, resource-based
- *Resource-based policies* control what actions a specified principal can
  perform on that resource and under what conditions. They are permissions
  policies that you attach to a resource such as an Amazon S3 bucket or an IAM
  role trust policy.  To enable cross-account access, you can specify an entire
  account or IAM entities in another account as the principal in a
  resource-based policy.

  #+CINDEX:role trust policy
  #+CINDEX:trust policy
  - The IAM service supports only one type of resource-based policy called a
    role trust policy, which is attached to an IAM role.

  - Because an IAM role is both an identity and a resource that supports
    resource-based policies, you must attach both a trust policy and an
    identity-based policy to an IAM role.

  - Trust policies define which principal entities (accounts, users, roles, and
    federated users) can assume the role.

  - To learn how IAM roles are different from other resource-based policies,
    see [[https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_compare-resource-policies.html][How IAM Roles Differ from Resource-based Policies]].


To see which services support resource-based policies, see [[https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_aws-services-that-work-with-iam.html][AWS Services That
Work with IAM]].

To learn more about resource-based policies, see [[https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_identity-vs-resource.html][Identity-Based Policies and
Resource-Based Policies]].

** Use Cases

#+CINDEX:AWS resources, access to
#+CINDEX:resources, access to AWS
#+ATTR_TEXINFO: :indic b
- Fine-grained access control to AWS resources ::
     #+CINDEX:AWS service APIs, access to
     #+CINDEX:service APIs, access to
  - IAM enables your users to control *access* to /AWS service APIs/ and to
    specific /resources/.
    #+CINDEX:conditions on use, AWS IAM
    #+CINDEX:originating IP address
    #+CINDEX:SSL, using
    #+CINDEX:authenticated using MFA
    #+CINDEX:MFA
  - IAM also enables you to add specific *conditions* such as time of day to
    control how a user can use AWS, their originating IP address, whether they
    are using SSL, or whether they have authenticated with a multi-factor
    authentication device.

    #+CINDEX:access control, mobile applications
    #+CINDEX:Web Identity Providers
    #+CINDEX:security credentials, temporary
- Manage access control for mobile applications with Web Identity Providers ::
  - You can enable your mobile and browser-based applications to securely
    access AWS resources by requesting *temporary security credentials* that
    grant access only to specific AWS resources for a configurable period of
    time.

    #+CINDEX:Multi-factor authentication
- Multi-factor authentication for highly privileged users ::
  - Protect your AWS environment by using AWS MFA, a security feature
    available at no extra cost that augments user name and password
    credentials.
  - MFA requires users to prove physical possession of a hardware MFA token or
    MFA-enabled mobile device by providing a valid MFA code.

    #+CINDEX:identity management
    #+CINDEX:corporate directory
    #+CINDEX:employees
    #+CINDEX:federated access
    #+CINDEX:SAML 2.0
    #+CINDEX:AWS Console SSO
    #+CINDEX:API federation
- Integrate with your corporate directory ::
     - IAM can be used to grant your employees and applications *federated
       access* to the AWS Management Console and AWS service APIs, using your
       existing identity systems such as Microsoft Active Directory.
     - You can use any identity management solution that supports SAML 2.0, or
       feel free to use one of our federation samples (AWS Console SSO or API
       federation).

** Features of IAM

#+CINDEX:features of IAM
#+CINDEX:shared access
- Shared access to your AWS account ::
     You can grant other people permission to administer and use resources in
     your AWS account without having to share your password or access key.
     #+CINDEX:permissions, granular
- Granular Permissions ::
     You can grant different permissions to different people for different
     resources.

     For example, you might allow some users complete access to Amazon Elastic
     Compute Cloud (Amazon EC2), Amazon Simple Storage Service (Amazon S3),
     Amazon DynamoDB, Amazon Redshift, and other AWS services.

     For other users, you can allow read-only access to just some S3 buckets,
     or permission to administer just some EC2 instances, or to access your
     billing information but nothing else.
     #+CINDEX:credentials for EC2
- Secure access to AWS resources for applications that run on Amazon EC2 ::
     You can use IAM features to securely provide credentials for applications
     that run on EC2 instances. These credentials provide permissions for your
     application to access other AWS resources. Examples include S3 buckets and
     DynamoDB tables.
     #+CINDEX:multi-factor authentication
- Multi-factor authentication (MFA) ::
     You can add two-factor authentication to your account and to individual
     users for extra security. With MFA you or your users must provide not only
     a password or access key to work with your account, but also a code from a
     specially configured device.
     #+CINDEX:identify federation
- Identity federation ::
     You can allow users who already have passwords elsewhere---for example, in
     your corporate network or with an internet identity provider---to get
     temporary access to your AWS account.
     #+CINDEX:CloudTrail
     #+CINDEX:log requests for resources
     #+CINDEX:resources, logged requests
- Identity information for assurance ::
     f you use [[https://aws.amazon.com/cloudtrail/][AWS CloudTrail]], you receive log records that include information
     about those who made requests for resources in your account. That
     information is based on IAM identities.
     #+CINDEX:Payment Card Industry
     #+CINDEX:PCI
     #+CINDEX:Data Security Standard
     #+CINDEX:DSS
- PCI DSS Compliance ::
     IAM supports the processing, storage, and transmission of credit card data
     by a merchant or service provider, and has been validated as being
     compliant with {{{dfn(Payment Card Industry)}}} (PCI) {{{dfn(Data Security
     Standard)}}} (DSS).
     #+CINDEX:services, integrated with IAM
- Integrated with many AWS services ::
     For a list of AWS services that work with IAM, see [[https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_aws-services-that-work-with-iam.html][AWS Services That Work
     with IAM]].

** How It Works

#+CINDEX:roles, create
#+CINDEX:permissions, create
{{{heading(IAM assists in creating roles and permissions.)}}}

AWS IAM allows you to:

#+CINDEX:IAM users, manage
#+CINDEX:users, manage IAM
#+CINDEX:access, manage IAM
#+ATTR_TEXINFO: :indic b
- Manage IAM users and their access ::
  - You can [[https://console.aws.amazon.com/iam/home?#/users][*create users*]] in IAM,
  - [[https://console.aws.amazon.com/iam/home?#/users/Pinecone?section=security_credentials][*assign security credentials*]] to individual users (in other words, access
    keys, passwords, and multi-factor authentication devices), or
  - *request temporary security credentials* to provide users access to AWS
    services and resources.
  - You can manage *permissions* in order to control which operations a user
    can perform.

- Manage IAM roles and their permissions ::
  - You can *create roles* in IAM and manage permissions to control which
    operations can be performed by the entity, or AWS service, that assumes the
    role.
  - You can also *define which entity* is allowed to assume the role. In
    addition, you can use service-linked roles to delegate permissions to AWS
    services that create and manage AWS resources on your behalf.

- Manage federated users and their permissions ::
  - You can enable *identity federation* to allow existing identities (users,
    groups, and roles) in your enterprise to
    - access the AWS Management Console,
    - call AWS APIs, and
    - access resources, without the need to create an IAM user for each identity.
  - Use any identity management solution that supports SAML 2.0, or use one of
    our federation samples (AWS Console SSO or API federation).

*** Accessing IAM

You can work with AWS Identity and Access Management in any of the following
ways.

#+CINDEX:management console
#+CINDEX:console, AWS management
- AWS Management Console ::
     The console is a browser-based interface to manage IAM and AWS resources.

     See [[https://docs.aws.amazon.com/IAM/latest/UserGuide/console.html][The IAM Console and Sign-in Page]].

     #+CINDEX:management console, tutorial
     For a tutorial that guides you through using the console, see [[https://docs.aws.amazon.com/IAM/latest/UserGuide/getting-started_create-admin-group.html][Creating
     Your First IAM Admin User and Group]].

     #+CINDEX:command-line tools
- AWS Command Line Tools ::
     You can use the AWS command line tools to issue commands at your system's
     command line to perform IAM and AWS tasks.

     Using the command line can be faster and more convenient than the
     console. The command line tools are also useful if you want to build
     scripts that perform AWS tasks.

     AWS provides two sets of command line tools:
  - the [[https://aws.amazon.com/cli/][AWS Command Line Interface]] (AWS CLI); see the [[https://docs.aws.amazon.com/cli/latest/userguide/][AWS Command Line
    Interface User Guide]].
  - the [[https://aws.amazon.com/powershell/][AWS Tools for Windows PowerShell]]

    #+CINDEX:software development kits
    #+CINDEX:SDKs for IAM
- AWS SDKs ::
     AWS provides SDKs (software development kits) that consist of libraries
              and sample code for various programming languages and platforms
              (Java, Python, Ruby, .NET, iOS, Android, etc.).  The SDKs provide
              a convenient way to create programmatic access to IAM and AWS.

              For example, the SDKs take care of tasks such as
              cryptographically signing requests, managing errors, and retrying
              requests automatically.

              See the [[https://aws.amazon.com/tools/][Tools for Amazon Web Services]] page.
  #+CINDEX:HTTPS API
- IAM HTTPS API ::
                   You can access IAM and AWS programmatically by using the IAM
                   HTTPS API, which lets you issue HTTPS requests directly to
                   the service.  When you use the HTTPS API, you must include
                   code to digitally sign requests using your credentials.

                   See [[https://docs.aws.amazon.com/IAM/latest/UserGuide/programming.html][Calling the API by Making HTTP Query Requests]];

                   See also the [[https://docs.aws.amazon.com/IAM/latest/APIReference/][IAM API Reference]].
** Manage Users

#+CINDEX:users, manage
#+CINDEX:users, definition
#+CINDEX:federating
For greater security and organization, you can give access to your AWS account
to specific {{{dfn(users)}}}---identities that you create with custom
permissions. You can further simplify access for those users by /federating/
existing identities into AWS.

[[https://aws.amazon.com/iam/details/manage-users/]]

https://docs.aws.amazon.com/IAM/latest/UserGuide/introduction_identity-management.html

#+CINDEX:IAM users
#+CINDEX:users, manage IAM
#+CINDEX:manage IAM users
#+CINDEX:users, create
#+CINDEX:security credentials
#+CINDEX:access keys
#+CINDEX:passwords
#+CINDEX:multi-factor authentication devices
#+CINDEX:temporary security credentials
#+CINDEX:permissions, manage
#+CINDEX:operations, allowed
Manage IAM users and their access:

- You can create users in IAM,
- assign them individual security credentials (such as access keys, passwords, and
  multi-factor authentication devices), or
- request temporary security credentials to provide users access to AWS services and resources.
- You can manage permissions in order to control which operations a user can perform.


IAM users can be:

#+CINDEX:administrators, privileged
#+CINDEX:resources, manage AWS
#+CINDEX:end users
#+CINDEX:systems, access data in AWS
1. Privileged administrators who need console access to manage your AWS
   resources.
2. End users who need access to content in AWS.
3. Systems that need privileges to programmatically access your data in AWS.

*** General Use Cases for Creating IAM Users

#+CINDEX:root account, do not use
#+CINDEX:least privilege
{{{subheading(Principle of Least Privilege)}}}

- It is a security best practice to not use your root account because the root
  account grants access to all services and resources. Grant users the minimum
  amount of privilege necessary, which is known as {{{dfn(least privilege)}}}.

{{{subheading(Assign Policies)}}}

  #+CINDEX:policies, assign to users
- You have other people in your group who have varied access and authorization
  permissions. When you use IAM users, it is easier to assign policies to
  specific users that access specific services and associated resources.

{{{subheading(Use the CLI)}}}

  #+CINDEX:AWS CLI
  #+CINDEX:CLI, AWS
- An IAM user can use the AWS CLI.

{{{subheading(Use Roles)}}}

  #+CINDEX:role, IAM user
  #+CINDEX:IAM user role
  #+CINDEX:user role, IAM
- An IAM user can use a role.

*** Create an IAM User

#+CINDEX:create IAM user, canonical
#+CINDEX:IAM user, create, canonical
#+CINDEX:user, create IAM, canonical
The following diagram describes the canonical use case for creating an IAM
user:

1. Create user
2. Give user security credentials
3. Put user into one or more groups
4. Give user a login profile (optional)

*** Using Groups for Easy Administration

#+CINDEX:IAM user group
#+CINDEX:user group, IAM
#+CINDEX:group, IAM user
A {{{dfn(group)}}} is a collection of IAM users.

#+CINDEX:permissions, assign to group of IAM users
Groups let you assign permissions to a collection of users, which can make it
easier to manage the permissions for those users.

#+BEGIN_cartouche
For example, you could have a group called =Admins= and give that group the
types of permissions that administrators typically need. Any user in that group
automatically has the permissions that are assigned to the group. If a new user
joins your organization and should have administrator privileges, you can
assign the appropriate permissions by adding the user to that group. Similarly,
if a person changes jobs in your organization, instead of editing that user's
permissions, you can remove him or her from the old group and add him or her to
the new group.
#+END_cartouche

*** Web Identity Federation

#+CINDEX:mobile app, access AWS resources
#+CINDEX:app, access AWS resources
#+CINDEX:access AWS resources, mobile app
#+CINDEX:resources, access AWS resources
Imagine that you are creating a mobile app that accesses AWS resources, such as
a game that runs on a mobile device and stores player and score information
using Amazon S3 and DynamoDB.

#+CINDEX:requests to AWS services
#+CINDEX:access key
When you write such an app, you'll make requests to AWS services that must be
signed with an AWS access key.

*However, we strongly recommend that you do not embed or distribute long-term
AWS credentials with apps that a user downloads to a device*, even in an
encrypted store.

#+CINDEX:request temporary AWS security credentials
#+CINDEX:temporary AWS security credentials
#+CINDEX:security credentials, temporary, request for
#+CINDEX:credentials, request for temporary security
#+CINDEX:dynamic request, temporary security credentials
#+CINDEX:web identity federation
#+CINDEX:AWS role
#+CINDEX:role
#+CINDEX:permissions to perform task
Instead, build your app so that it requests /temporary AWS security
credentials/ dynamically when needed using *web identity federation*.  The
supplied temporary credentials map to an AWS role that has only the permissions
needed to perform the tasks required by the mobile app.

#+CINDEX:external identity provider (IdP)
#+CINDEX:identity provider (IdP), external
#+CINDEX:Login with Amazon
#+CINDEX:Amazon
#+CINDEX:Facebook
#+CINDEX:Google
#+CINDEX:OpenID Connect (OIDC)
#+CINDEX:IdP
#+CINDEX:authentication token
#+CINDEX:temporary security credentials
#+CINDEX:role with permissions
With web identity federation, you don't need to create custom sign-in code or
manage your own user identities. Instead, users of your app can sign in using a
well-known external identity provider (IdP), such as Login with Amazon,
Facebook, Google, or any other OpenID Connect (OIDC)-compatible IdP. They can
receive an authentication token, and then exchange that token for temporary
security credentials in AWS that map to an IAM role with permissions to use the
resources in your AWS account. Using an IdP helps you keep your AWS account
secure, because you don't have to embed and distribute long-term security
credentials with your application.

{{{heading(Use Amazon Cognito)}}}

#+CINDEX:Amazon Cognito
#+CINDEX:identity broker
For most scenarios, we recommend that you use Amazon Cognito because it acts as
an identity broker and does much of the federation work for you.

#+CINDEX:mobile apps, Amazon Cognito
For details, see the following section, [[https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_oidc_cognito.html][Using Amazon Cognito for Mobile Apps]].

{{{subheading(Assume Role with Web Identities API)}}}

#+CINDEX:@code{AssumeRoleWithWebIdentity} API
#+CINDEX:authentication token, trade for security credentials
If you don't use Amazon Cognito, then you must write code that interacts with a
web IdP, such as Facebook, and then calls the ~AssumeRoleWithWebIdentity~ API
to trade the authentication token you get from those IdPs for AWS temporary
security credentials. If you have already used this approach for existing apps,
you can continue to use it.

The process for using web identity federation without Amazon Cognito follows
this general outline:
https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_oidc_manual.html

**** Web Identity Federation Playground

#+CINDEX:Web Identity Federation Playground
#+CINDEX:web identity federation
#+CINDEX:authenticating via service
#+CINDEX:temporary security credentials
#+CINDEX:security credentials, temporary
#+CINDEX:credentials, temporary security
#+CINDEX:request to AWS, using credentials
To help understand how web identity federation works, you can use the [[https://web-identity-federation-playground.s3.amazonaws.com/index.html][Web
Identity Federation Playground]].  This interactive website lets you walk through
the process of authenticating via Login with Amazon, Facebook, or Google,
getting temporary security credentials, and then using those credentials to
make a request to AWS.

**** Identifying Users with Web Identity Federation

When you create access policies in IAM, it's often useful to be able to specify
permissions based on configured apps and on the ID of users who have
authenticated using an external identity provider (IdP).

For example, your mobile app that's using web identity federation might keep
information in Amazon S3 using a structure like this:

#+BEGIN_EXAMPLE
myBucket/app1/user1
myBucket/app1/user2
myBucket/app1/user3
...
myBucket/app2/user1
myBucket/app2/user2
myBucket/app2/user3
...
#+END_EXAMPLE

You might also want to additionally distinguish these paths by provider. In
that case, the structure might look like the following (only two providers are
listed to save space):

#+BEGIN_EXAMPLE
myBucket/Amazon/app1/user1
myBucket/Amazon/app1/user2
myBucket/Amazon/app1/user3
...
myBucket/Amazon/app2/user1
myBucket/Amazon/app2/user2
myBucket/Amazon/app2/user3

myBucket/Facebook/app1/user1
myBucket/Facebook/app1/user2
myBucket/Facebook/app1/user3
...
myBucket/Facebook/app2/user1
myBucket/Facebook/app2/user2
myBucket/Facebook/app2/user3
...
#+END_EXAMPLE

For these structures, app1 and app2 represent different apps, such as different
games, and each user of the app has a distinct folder. The values for app1 and
app2 might be friendly names that you assign (for example, ~mynumbersgame~) or
they might be the app IDs that the providers assign when you configure your
app. If you decide to include provider names in the path, those can also be
friendly names like Cognito, Amazon, Facebook, and Google.

#+CINDEX:AWS Management Console
#+CINDEX:run time, folder creation
#+CINDEX:@code{SubjectFromWebIdentityToken} value
#+CINDEX:@code{AssumeRoleWithWebIdentity}
You can typically create the folders for app1 and app2 through the AWS
Management Console, since the application names are static values. That's true
also if you include the provider name in the path, since the provider name is
also a static value. In contrast, the user-specific folders (user1, user2,
user3, etc.) have to be created at run time from the app, using the user ID
that's available in the ~SubjectFromWebIdentityToken~ value that is returned by
the request to ~AssumeRoleWithWebIdentity~.

To write policies that allow exclusive access to resources for individual
users, you can match the complete folder name, including the app name and
provider name, if you're using that. You can then include the following
provider-specific context keys that reference the user ID that the provider
returns:

- cognito-identity.amazonaws.com:sub
- www.amazon.com:user_id
- graph.facebook.com:id
- accounts.google.com:sub


For OIDC providers, use the fully qualified URL of the OIDC provider with the
subcontext key, like the following example:

- server.example.com:sub


The following example shows a permission policy that grants access to a bucket
in Amazon S3 only if the prefix for the bucket matches the string:
: myBucket/Amazon/mynumbersgame/user1

The example assumes that the user is signed in using Login with Amazon, and
that the user is using an app called mynumbersgame. The user's unique ID is
presented as an attribute called user_id.

#+BEGIN_EXAMPLE
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": ["s3:ListBucket"],
      "Resource": ["arn:aws:s3:::myBucket"],
      "Condition": {"StringLike": {"s3:prefix": ["Amazon/mynumbersgame/${www.amazon.com:user_id}/*"]}}
    },
    {
      "Effect": "Allow",
      "Action": [
        "s3:GetObject",
        "s3:PutObject",
        "s3:DeleteObject"
      ],
      "Resource": [
        "arn:aws:s3:::myBucket/amazon/mynumbersgame/${www.amazon.com:user_id}",
        "arn:aws:s3:::myBucket/amazon/mynumbersgame/${www.amazon.com:user_id}/*"
      ]
    }
  ]
}
#+END_EXAMPLE

You would create similar policies for users who sign in using Amazon Cognito,
Facebook, Google, or another OpenID Connect–compatible IdP. Those policies
would use a different provider name as part of the path as well as different
app IDs.

** Manage Permissions

[[https://aws.amazon.com/iam/details/manage-permissions/]]

#+CINDEX:IAM permissions
#+CINDEX:permissions, IAM
#+CINDEX:AWS resources, access to
{{{dfn(Permissions)}}} let you specify access to AWS resources.

Permissions are granted to IAM entities (users, groups, and roles) and by
default these entities start with no permissions. In other words, IAM entities
can do nothing in AWS until you grant them your desired permissions.

#+CINDEX:policy, attach
To give entities permissions, you can attach a policy that specifies
- the type of access,
- the actions that can be performed, and
- the resources on which the actions can be performed.
- In addition, you can specify any conditions that must be set for access to be
  allowed or denied.

*** Assign Permissions

#+CINDEX:permissions, assign
#+CINDEX:policy, create
To assign permissions to a user, group, role, or resource, you create a policy
that lets you specify:

#+ATTR_TEXINFO: :indic b
- Actions ::
             Which AWS service actions you allow. For example, you might allow
             a user to call the Amazon S3 ListBucket action. Any actions that
             you don't explicitly allow are denied.
- Resources ::
               Which AWS resources you allow the action on. For example, what
               Amazon S3 buckets will you allow the user to perform the
               ListBucket action on? Users cannot access any resources that you
               do not explicitly grant permissions to.
- Effect ::
            Whether to allow or deny access. Because access is denied by
            default, you typically write policies where the effect is to allow.
- Conditions ::
                Which conditions must be present for the policy to take
                effect. For example, you might allow access only to the
                specific S3 buckets if the user is connecting from a specific
                IP range or has used multi-factor authentication at login.

*** Create Policies

#+CINDEX:policies, create
#+CINDEX:create policies
#+CINDEX:visual editor, create policies
#+CINDEX:JSON, create policies
You create policies by using either the visual editor or JSON.

#+CINDEX:policy
#+CINDEX:permissions, set of
A {{{dfn(policy)}}} consists of one or more statements, each of which describes
one set of permissions.

#+CINDEX:AWS IAM Policy Reference
#+CINDEX:policy language
To learn more about the policy language, see [[http://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies.html][AWS IAM Policy Reference]].

**** Visual Editor

#+CINDEX:visual editor
#+CINDEX:permissions, grant
#+CINDEX:IAM policies
#+CINDEX:policies, create using visual editor
#+CINDEX:actions, List and Read
#+CINDEX:S3 bucket actions
The visual editor guides you through granting permissions by using IAM policies
without requiring you to write the policies in JSON (although you can still
author and edit policies in JSON, if you prefer). The policy in the following
screenshot was created with the visual editor. It grants five Amazon S3 List
and Read actions to the S3 bucket and objects in SampleBucket if the prefix
starts with MyPrefix.

#+NAME:img:manage-permissions
#+CAPTION:Policy created using the Visual Editor
[[file:img/ManagePermissions.jpg]]

*** View Policy Summaries

#+CINDEX:policy summaries, view
#+CINDEX:view policy summaries
#+CINDEX:AWS Management Console
#+CINDEX:manage permissions
#+CINDEX:permissions, manage
#+CINDEX:access levels
#+CINDEX:List access level
#+CINDEX:Read access level
#+CINDEX:Write access level
#+CINDEX:Permissions access level
#+CINDEX:policy permissions
#+CINDEX:permissions, policy
#+CINDEX:actions, AWS service
#+CINDEX:AWS service action policy
If you use the AWS Management Console to manage permissions, you can view
policy summaries. A {{{dfn(policy summary)}}} /lists the access level,
resources, and conditions for each service defined in a policy/ (see the
following screenshot for an example). To help you understand the permissions
defined in a policy, each AWS service’s actions are categorized in four access
levels: List, Read, Write, and Permissions management.

#+NAME:img:view-policies
#+CAPTION:View policy summaries
[[file:img/JC1final-UPDATED_65.png]]

#+CINDEX:predefined policy, select
#+CINDEX:policy generator, create own policy
#+CINDEX:policy, predefined by AWS
You can select a predefined policy managed by AWS or create your own using the
policy generator. For more information, see the [[http://docs.aws.amazon.com/IAM/latest/UserGuide/PoliciesOverview.html][Overview of IAM Policies]]
section of the [[http://docs.aws.amazon.com/IAM/latest/UserGuide/][Using IAM guide]].

** Getting started with AWS IAM

https://aws.amazon.com/iam/getting-started/

AWS IAM helps you manage access to your AWS resources.  Using IAM, you can
manage:
#+ATTR_TEXINFO: :indic b
- Authentication :: who can use your AWS resources and
- Authorization :: what resources they can use and in what ways.

{{{heading(Tutorials and guides)}}}

Get started with AWS Identity and Access Management (IAM) quickly using the
following tutorials and guides:

- What is AWS Identity and Access Management (IAM), and what can I do with it [[https://aws.amazon.com/premiumsupport/knowledge-center/iam-intro/][==>]]
- User Guide: Getting Started [[http://docs.aws.amazon.com/IAM/latest/UserGuide/getting-started.html][==>]]
- What is an IAM user and what can an IAM user do [[https://aws.amazon.com/premiumsupport/knowledge-center/iam-user-basics/][==>]]
- How to create a new IAM user [[https://aws.amazon.com/premiumsupport/knowledge-center/create-new-iam-user/][==>]]
- Tutorial: Delegate Access to the Billing Console [[http://docs.aws.amazon.com/IAM/latest/UserGuide/tutorial_billing.html][==>]]
- Tutorial: Delegate Access Across AWS Accounts Using IAM Roles [[http://docs.aws.amazon.com/IAM/latest/UserGuide/tutorial_cross-account-with-roles.html][==>]]
- Tutorial: Create and Attach Your First Customer Managed Policy [[http://docs.aws.amazon.com/IAM/latest/UserGuide/tutorial_managed-policies.htmlhttp://docs.aws.amazon.com/IAM/latest/UserGuide/tutorial_managed-policies.html][==>]]
- Tutorial: Enable Your Users to Configure Their Own Credentials and MFA
  Settings [[http://docs.aws.amazon.com/IAM/latest/UserGuide/tutorial_users-self-manage-mfa-and-creds.html][==>]]


Want to learn more? See
- [[http://docs.aws.amazon.com/IAM/latest/UserGuide/tutorials.html][AWS IAM Tutorials]] and
- the [[https://aws.amazon.com/premiumsupport/knowledge-center/#iam][AWS IAM section in the Knowledge Center]].

** Best Practices

#+CINDEX:recommended best practices
#+CINDEX:real-world scenarios
To get the greatest benefits from IAM, take time to learn the recommended best
practices. One way to do this is to see how IAM is used in real-world scenarios
to work with other AWS services.

*** Lock Away Your AWS Account Root User Access Keys
:PROPERTIES:
:CUSTOM_ID: root_user
:END:

#+CINDEX:programmatic requests to AWS
#+CINDEX:root user access keys, do not use
You use an access key (an access key ID and secret access key) to make
programmatic requests to AWS. However, do not use your AWS account root user
access key. The access key for your AWS account root user gives full access to
all your resources for all AWS services, including your billing
information. You cannot reduce the permissions associated with your AWS account
root user access key.

Therefore, protect your root user access key like you would your credit card
numbers or any other sensitive secret. Here are some ways to do that:

#+CINDEX:root user access key, do not create
#+CINDEX:IAM user, create with administrative permissions
- If you don't already have an access key for your AWS account root user, don't
  create one unless you absolutely need to. Instead, use your account email
  address and password to sign in to the AWS Management Console and create an
  IAM user for yourself that has administrative permissions.

  #+CINDEX:root user access key, delete
- If you do have an access key for your AWS account root user, delete it.

- Never share your AWS account root user password or access keys with anyone.

- Use a strong password to help protect account-level access to the AWS
  Management Console.

  #+CINDEX:multi-factor authentication, root user account
- Enable AWS multi-factor authentication (MFA) on your AWS account root user
  account.

*** Create Individual IAM Users

#+CINDEX:create individual users
#+CINDEX:IAM user with administrative permissions
Don't use your AWS account root user credentials to access AWS, and don't give
your credentials to anyone else. Instead, create individual users for anyone
who needs access to your AWS account. Create an IAM user for yourself as well,
give that user administrative permissions, and use that IAM user for all your
work.

For information about how to do this, see

#+CINDEX:IAM user, create first
- [[https://docs.aws.amazon.com/IAM/latest/UserGuide/getting-started_create-admin-group.html][Creating Your First IAM Admin User and Group]].

By creating individual IAM users for people accessing your account, you can
give each IAM user a unique set of security credentials. You can also grant
different permissions to each IAM user. If necessary, you can change or revoke
an IAM user's permissions any time.

*** Use Groups to Assign Permissions to IAM Users

#+CINDEX:groups, assign permissions to
Instead of defining permissions for individual IAM users,

#+CINDEX:job functions
- it's usually more convenient to create groups that relate to job functions
  (administrators, developers, accounting, etc.).

- Next, define the relevant permissions for each group.

  #+CINDEX:users, assign to groups
- Finally, assign IAM users to those groups.


All the users in an IAM group inherit the permissions assigned to the
group. That way, you can make changes for everyone in a group in just one
place. As people move around in your company, you can simply change what IAM
group their IAM user belongs to.

#+CINDEX:manage IAM groups
#+CINDEX:groups, manage
- [[https://docs.aws.amazon.com/IAM/latest/UserGuide/id_groups_manage.html][Managing IAM Groups]]

*** Grant Least Privilege

#+CINDEX:least privilege
#+CINDEX:tasks, policies for
When you create IAM policies, follow the standard security advice of granting
/least privilege/, or granting only the permissions required to perform a
task. Determine what users need to do and then craft policies for them that let
the users perform /only/ those tasks.

#+CINDEX:permissions, minimum set
Start with a minimum set of permissions and grant additional permissions as
necessary. Doing so is more secure than starting with permissions that are too
lenient and then trying to tighten them later.

#+CINDEX:access level groupings
#+CINDEX:policy actions
#+CINDEX:List
#+CINDEX:Read
#+CINDEX:Write
#+CINDEX:Permissions manaagement
#+CINDEX:Tagging
You can use access level groupings to understand the level of access that a
policy grants. *Policy actions* are classified as:

- =List=,
- =Read=,
- =Write=,
- =Permissions management=, or
- =Tagging=.


#+CINDEX:read-only access
For example, you can choose actions from the =List= and =Read= access levels to
grant read-only access to your users.

#+CINDEX:policy summaries, use
#+CINDEX:access level permissions
To learn how to use policy summaries to understand access level permissions, see

- [[https://docs.aws.amazon.com/IAM/latest/UserGuide/best-practices.html#use-access-levels-to-review-permissions][Use Access Levels to Review IAM Permissions]].

{{{subheading(Service Last Accessed Data)}}}

#+CINDEX:service last accessed data
#+CINDEX:Access Advisor tab
#+CINDEX:IAM console details page
One feature that can help with this is /service last accessed data/. View this
data on the {{{key(Access Advisor)}}} tab on the =IAM console details= page for
a user, group, role, or policy.

#+CINDEX:AWS CLI, service last accessed data
#+CINDEX:AWS API, service last accessed data
You can also use the AWS CLI or AWS API to retrieve /service last accessed
data/.

#+CINDEX:unnecessary permissions, identify
This data includes information about which services a user, group, role, or
anyone using a policy attempted to access and when. You can use this
information to identify unnecessary permissions so that you can refine your IAM
policies to better adhere to the principle of least privilege.

For more information, see:

#+CINDEX:reducing permissions, service last accessed data
- [[https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html][Reducing Permissions Using Service Last Accessed Data]]

{{{subheading(CloudTrail Event history)}}}

#+CINDEX:CloudTrail Event history
#+CINDEX:Event history, CloudTrail
To further reduce permissions, you can view your account's events in CloudTrail
*Event history*. CloudTrail event logs include detailed event information that
you can use to reduce the policy's permissions and include only the actions and
resources that your IAM entities need.

For more information, see (in the AWS CloudTrail User Guide):

#+CINDEX:CloudTrail Events in CloudTrail Console
- [[https://docs.aws.amazon.com/awscloudtrail/latest/userguide/view-cloudtrail-events-console.html][Viewing CloudTrail Events in the CloudTrail Console]]

**** Access Management

#+CINDEX:access management
https://docs.aws.amazon.com/IAM/latest/UserGuide/access.html

**** Policy topics for individual services

#+CINDEX:write policies
#+CINDEX:policies, write for service-specific resources
provide examples of how to write policies for service-specific resources

#+CINDEX:Amazon DynamoDB, authentication, access control
- [[https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/UsingIAMWithDDB.html][Authentication and Access Control for Amazon DynamoDB]] in the /Amazon DynamoDB
  Developer Guide/

  #+CINDEX:bucket policies
  #+CINDEX:policies, bucket and user
  #+CINDEX:Amazon Simple Storage Service
- [[https://docs.aws.amazon.com/AmazonS3/latest/dev/using-iam-policies.html][Using Bucket Policies and User Policies]] in the /Amazon Simple Storage Service
  Developer Guide/

  #+CINDEX:Access Control List (ACL)
- [[https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html][Access Control List (ACL) Overview]] in the /Amazon Simple Storage Service
  Developer Guide/

*** Get Started Using Permissions With AWS Managed Policies

#+CINDEX:AWS managed policies
#+CINDEX:managed policies
#+CINDEX:policies, managed
To get started quickly, you can use AWS managed policies to give your employees
the permissions they need to get started. These policies are already available
in your account and are maintained and updated by AWS. For more information
about AWS managed policies, see [[https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_managed-vs-inline.html#aws-managed-policies][AWS Managed Policies]].

AWS managed policies are designed to provide permissions for many common use
cases.  AWS managed policies make it easier for you to assign appropriate
permissions to users, groups, and roles than if you had to write the policies
yourself.

#+CINDEX:full access managed policy
#+CINDEX:managed policy, full access
#+CINDEX:AmazonDynamoDBFullAccess
#+CINDEX:IAMFullAccess
- Full Access ::
                 Full access AWS managed policies such as
                 [[https://console.aws.amazon.com/iam/home#policies/arn:aws:iam::aws:policy/AmazonDynamoDBFullAccess][AmazonDynamoDBFullAccess]] and [[https://console.aws.amazon.com/iam/home#policies/arn:aws:iam::aws:policy/IAMFullAccess][IAMFullAccess]] define permissions
                 for service administrators by granting full access to a
                 service.

                 #+CINDEX:power user managed policy
                 #+CINDEX:managed policy, power user
                 #+CINDEX:AWSCodeCommitPowerUser
                 #+CINDEX:AWSKeyManagementServicePowerUser
- Power User ::
                Power-user AWS managed policies such as [[https://console.aws.amazon.com/iam/home#policies/arn:aws:iam::aws:policy/AWSCodeCommitPowerUser][AWSCodeCommitPowerUser]]
                and [[https://console.aws.amazon.com/iam/home#policies/arn:aws:iam::aws:policy/AWSKeyManagementServicePowerUser][AWSKeyManagementServicePowerUser]] provide multiple levels of
                access to AWS services without allowing permissions management
                permissions.

                #+CINDEX:partial access managed policy
                #+CINDEX:managed policy, partial access
                #+CINDEX:AmazonMobileAnalyicsWriteOnlyAccess
                #+CINDEX:AmazonEC2ReadOnyAccess
- Partial Access ::
                    Partial-access AWS managed policies such as
                    [[https://console.aws.amazon.com/iam/home#policies/arn:aws:iam::aws:policy/AmazonMobileAnalyticsWriteOnlyAccess][AmazonMobileAnalyticsWriteOnlyAccess]] and
                    [[https://console.aws.amazon.com/iam/home#policies/arn:aws:iam::aws:policy/AmazonEC2ReadOnlyAccess][AmazonEC2ReadOnlyAccess]] provide specific levels of access
                    to AWS services.


#+CINDEX:managed policies for job functions
#+CINDEX:job functions, AWS managed policies
#+CINDEX:IT industry job functions
#+CINDEX:AWS Managed Policies for Job Functions
AWS managed policies for job functions can span multiple services and align
with common job functions in the IT industry. For a list and descriptions of
job function policies, see [[https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_job-functions.html][AWS Managed Policies for Job Functions]].

*** Use Customer Managed Policies Instead of Inline Policies

#+CINDEX:managed policies
#+CINDEX:inline policies
For custom policies, we recommend that you use managed policies instead of
inline policies.

#+CINDEX:inline policies, definition
#+CINDEX:IAM identity
{{{dfn(Inline policies)}}} are policies that exist only on an IAM identity
(user, group, or role).

#+CINDEX:managed policies, definition
#+CINDEX:multiple identities
{{{dfn(Managed policies)}}} are separate IAM resources that you can attach to
multiple identities.

For more information, see [[https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_managed-vs-inline.html][Managed Policies and Inline Policies]].

- A key advantage of using these policies is that you can view all of your
  managed policies in one place in the console.

- You can also view this information with a single AWS CLI or AWS API
  operation.


#+CINDEX:convert inline policies to managed policies
#+CINDEX:inline policies, convert to managed policies
If you have inline policies in your account, you can convert them to managed
policies. To do this, copy the policy to a new managed policy, attach the new
policy to the identity that has the inline policy, and then delete the inline
policy.

#+CINDEX:inline policies rather than managed policies
In some circumstances, we do recommend choosing inline policies over managed
policies. For details, see [[https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_managed-vs-inline.html#choosing-managed-or-inline][Choosing Between Managed Policies and Inline
Policies]].

*** Use Access Levels to Review IAM Permissions

#+CINDEX:review IAM policies
To improve the security of your AWS account, you should regularly review and
monitor each of your IAM policies. Make sure that your policies grant the least
privilege that is needed to perform only the necessary actions.

#+CINDEX:policy summary, view
#+CINDEX:access level, for each service
#+CINDEX:service action
#+CINDEX:List access level
#+CINDEX:Read access level
#+CINDEX:Write access level
#+CINDEX:Permissions management access level
When you review a policy, you can view the policy summary that includes a
summary of the access level for each service within that policy. AWS
categorizes each service action into one of four access levels based on what
each action does: List, Read, Write, or Permissions management. You can use
these access levels to determine which actions to include in your policies.

#+BEGIN_cartouche
For example, in the Amazon S3 service, you might want to allow a large group of
users to access List and Read actions. Such actions permit those users to list
the buckets and get objects in Amazon S3. However, you should allow only a
small group of users to access the Amazon S3 Write actions to delete buckets or
put objects into an S3 bucket. Additionally, you should reduce permissions to
allow only administrators to access the Amazon S3 Permissions management
actions. This ensures that only a limited number of people can manage bucket
policies in Amazon S3. This is especially important for Permissions management
actions in IAM and AWS Organizations services.
#+END_cartouche

#+CINDEX:access level classificationm, view
To view the access level classification that is assigned to each action in a
service, see [[https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_actions-resources-contextkeys.html][Actions, Resources, and Condition Keys for AWS Services]].

#+CINDEX:policy summary
#+CINDEX:Policies page for managed policies
#+CINDEX:Users page for policies attached to a user
To see the access levels for a policy, you must first locate the policy's
summary. The policy summary is included on the Policies page for managed
policies, and on the Users page for policies that are attached to a user. For
more information, see [[https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_understand-policy-summary.html][Policy Summary (List of Services)]].

#+CINDEX:policy summary, within
#+CINDEX:Access level column
#+CINDEX:Full access
#+CINDEX:Limited access
#+CINDEX:level of access, policy provides
Within a policy summary, the Access level column shows that the policy provides
Full or Limited access to one or more of the four AWS access levels for the
service. Alternately, it might show that the policy provides Full access to all
the actions within the service. You can use the information within this Access
level column to understand the level of access that the policy provides. You
can then take action to make your AWS account more secure. For details and
examples of the access level summary, see [[https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_understand-policy-summary-access-level-summaries.html][Understanding Access Level Summaries
Within Policy Summaries]].

*** Configure a Strong Password Policy for Your Users

#+CINDEX:strong passwords
#+CINDEX:passwords, strong, rotate
#+CINDEX:rotate passwords
If you allow users to change their own passwords, require that they create
strong passwords and that they rotate their passwords periodically.

#+CINDEX:Account Settings page of IAM console
-  [[https://console.aws.amazon.com/iam/home?#account_settings][Account Settings]] page of the IAM console ::
     Create a password policy for your account.  You can use the password
     policy to define password requirements, such as minimum length, whether it
     requires non-alphabetic characters, how frequently it must be rotated, and
     so on.


For more information, see [[https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_passwords_account-policy.html][Setting an Account Password Policy for IAM Users]].

*** Enable MFA for Privileged Users

#+CINDEX:multi-factor authentication (MFA)
#+CINDEX:privileged IAM users, definition
For extra security, enable multi-factor authentication (MFA) for
{{{dfn(privileged IAM users)}}} (users who are allowed access to sensitive
resources or API operations).

For more information, see [[https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_mfa.html][Using Multi-Factor Authentication (MFA) in AWS]].

*** Use Roles for Applications That Run on Amazon EC2 Instances

#+CINDEX:Amazon EC2
#+CINDEX:credentials, EC2 instance
Applications that run on an Amazon EC2 instance need credentials in order to
access other AWS services. To provide credentials to the application in a
secure way, use IAM roles.

#+CINDEX:role, definition
- Role ::
          A {{[dfn(role)}}} is an entity that has its own set of permissions,
          but that isn't a user or group.  Roles also don't have their own
          permanent set of credentials the way IAM users do.
#+CINDEX:temporary credentials
#+CINDEX:credentials, temporary
- Temporary credentials ::
     In the case of Amazon EC2, IAM dynamically provides temporary credentials
     to the EC2 instance, and these credentials are automatically rotated for
     you.


#+CINDEX:EC2 instance launch
#+CINDEX:launch EC2 instance
#+CINDEX:role, specify for an instance
#+CINDEX:launch parameter, role
#+CINDEX:permissions, role
#+CINDEX:role permissions
When you launch an EC2 instance, you can specify a role for the instance as a
launch parameter.  Applications that run on the EC2 instance can use the role's
credentials when they access AWS resources.  The role's permissions determine
what the application is allowed to do.

For more information, see [[https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use_switch-role-ec2.html][Using an IAM Role to Grant Permissions to
Applications Running on Amazon EC2 Instances]].

*** Use Roles to Delegate Permissions

#+CINDEX:security credentials, no sharing
#+CINDEX:IAM roles, not sharing
#+CINDEX:roles, define
Don't share security credentials between accounts to allow users from another
AWS account to access resources in your AWS account. Instead, use IAM
roles. You can define a role that specifies what permissions the IAM users in
the other account are allowed. You can also designate which AWS accounts have
the IAM users that are allowed to assume the role.

For more information, see [[https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_terms-and-concepts.html][Roles Terms and Concepts]].

*** Do Not Share Access Keys

#+CINDEX:access keys
#+CINDEX:programmatic access, access keys
{{{dfn(Access keys)}}} provide programmatic access to AWS.

Do not embed access keys within unencrypted code or share these security
credentials between users in your AWS account.

#+CINDEX:temporary security credentials, roles
#+CINDEX:roles, temporary security credentials
For applications that need access to AWS, configure the program to retrieve
temporary security credentials using an IAM role.

#+CINDEX:IAM user
#+CINDEX:personal access key
To allow your users individual programmatic access, create an IAM user with
personal access keys.

*** Rotate Credentials Regularly

#+CINDEX:password policy
#+CINDEX:password, change frequently
Change your own passwords and access keys regularly, and make sure that all IAM
users in your account do as well. That way, if a password or access key is
compromised without your knowledge, you limit how long the credentials can be
used to access your resources. You can apply a password policy to your account
to require all your IAM users to rotate their passwords, and you can choose how
often they must do so.

*** Remove Unnecessary Credentials

Remove IAM user credentials (passwords and access keys) that are not needed.

#+CINDEX:credentials report
#+CINDEX:unused passwords, find
#+CINDEX:unused access keys, find
You can find unused passwords or access keys using the console, using the CLI
or API, or by downloading the credentials report.  See [[https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_finding-unused.html][Finding Unused
Credentials]].

*** Use Policy Conditions for Extra Security

#+CINDEX:conditions, define
To the extent that it's practical, define the conditions under which your IAM
policies allow access to a resource.

- For example, you can write conditions to specify a range of allowable IP
  addresses that a request must come from.

- You can also specify that a request is allowed only within a specified date
  range or time range.

- You can also set conditions that require the use of SSL or MFA (multi-factor
  authentication).

#+CINDEX:IAM JSON Policy Elements
For more information, see [[https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_condition.html][IAM JSON Policy Elements: Condition]] in the IAM Policy
Elements Reference.

*** Monitor Activity in Your AWS Account

#+CINDEX:logging features
You can use logging features in AWS to determine the actions users have taken
in your account and the resources that were used. The log files show the time
and date of actions, the source IP for an action, which actions failed due to
inadequate permissions, and more.

*** Video Presentation About IAM Best Practices

The following video includes a conference presentation that covers these best
practices and shows additional details about how to work with the features
discussed here.

[[https://youtu.be/_wiGpBQGCjU]]
* Amplify Framework
:PROPERTIES:
:APPENDIX: t
:END:

{{{heading(Develop With the Amplify Framework)}}}

{{{subheading(Build scalable cloud-powered apps)}}}

- [[https://aws-amplify.github.io][HOME]]
- [[https://aws-amplify.github.io/docs/js/start?platform=purejs][JAVASCRIPT DOCUMENTATION]]

``Amplify your apps. Build on a flexible, scalable, and reliable serverless
backend.''

- Library ::
             A comprehensive library for building sophisticated cloud-powered
             apps.  Choose your cloud services and easily connect them to your
             app with just a few lines of code.  iOS & Android are supported
             with our Native SDKs.

  - Categories:
    - Analytics
    - API
    - Authentication
    - Storage
    - Interactions
    - PubSub
    - Notifications
    - XR

  - Utilities
    - Cache
    - Hub
    - I18n
    - Logger
    - Service Worker

               #+CINDEX:toolchain
- Toolchain ::
               A powerful [[https://aws-amplify.github.io/media/toolchain][toolchain]] built for developers.

               #+CINDEX:CLI, Amplify
               #+CINDEX:Command Line Interface (CLI)
               The Amplify Command Line Interface (CLI) is a unified toolchain
               to create and manage your serverless infrastructure on AWS.

               #+CINDEX:backends, configure
               #+CINDEX:configure backends
               #+CINDEX:authentication
               #+CINDEX:analytics
               #+CINDEX:functions
               #+CINDEX:REST
               #+CINDEX:GraphQL
               #+CINDEX:CloudFormation
               - configure backends ::
                    The CLI includes support for authentication, analytics,
                    functions, REST/GraphQL APIs, and much more. The toolchain
                    uses AWS CloudFormation and enables you to add, modify, and
                    share configurations.
               #+CINDEX:static assets, websites
               #+CINDEX:host static websites
               #+CINDEX:Lambda functions
               #+CINDEX:deploy
               - host static assets and websites ::
                    Distribute content to end users with low latency and high
                    data transfer speeds via a secure, durable, and scalable
                    object storage infrastructure. You can perform local
                    testing of AWS Lambda functions, connect them to your APIs,
                    and deploy everything in one command.
               #+CINDEX:GraphQL Schema Definition Language (SDL)
               #+CINDEX:SDL
               #+CINDEX:CloudFormation template
               #+CINDEX:data model
               - create APIs and generate client code ::
                    Define your API using the GraphQL Schema Definition
                    Language (SDL). The toolchain will expand and transform a
                    full CloudFormation template that implements your data
                    model.

- UI Components ::
                   A beautiful [[https://aws-amplify.github.io/media/ui_library][component library]] connected to the cloud.

                   Launch your apps with our minimally-styled UI components or
                   change them to match your app style.

                   - Colors
                   - Typography
                   - Components for user authentication


** Get Started With Amplify

Amplify is ``an opinionated, category-based client framework for building
scalable mobile and web apps.''

- [[https://aws-amplify.github.io/docs/][GET STARTED]]


#+CINDEX:Amplify Framework
#+CINDEX:development, mobile and web
#+CINDEX:CLI, Amplify
#+CINDEX:command-line interface
The Amplify Framework provides a command-line interface (CLI) and library for
simplifying mobile and web development.[fn:11]

   #+CINDEX:AWS account
   #+CINDEX:sign up, AWS account
   #+CINDEX:account, AWS
1. Sign up for an AWS account.

   #+CINDEX:Free Tier
   There are no upfront charges or any term commitments to create an AWS
   account and signing up gives you immediate access to the AWS Free Tier.

   #+CINDEX:Amplify CLI
   #+CINDEX:CLI, Amplify
2. Install the CLI

   #+CINDEX:Amplify Command Line Interface (CLI)
   The Amplify Command Line Interface (CLI) is a unified toolchain to create,
   integrate, and manage the AWS cloud services for your app.

   - Install Node.js® and {{{command(npm)}}} if they are not already on your
     machine.[fn:12]

   - Install and configure the Amplify CLI.

     #+BEGIN_EXAMPLE
     $ npm install -g @aws-amplify/cli
     $ amplify configure
     #+END_EXAMPLE

   #+CINDEX:app, build
   #+CINDEX:build app
3. Build Your App

   #+CINDEX:iOS app
   - [[https://aws-amplify.github.io/docs/ios/start?ref=amplify-iOS-btn][iOS]]

   #+CINDEX:Android app
   - [[https://aws-amplify.github.io/docs/android/start?ref=amplify-android-btn][Android]]

   #+CINDEX:web app
   - [[https://aws-amplify.github.io/docs/js/start?ref=amplify-js-btn&platform=purejs][Web]]

   #+CINDEX:React Native app
   - [[https://aws-amplify.github.io/docs/js/start?ref=amplify-rn-btn&platform=react-native][React Native]]

   #+CINDEX:application services
4. Setup application services

5. Integrate with your app

{{{heading(Deploy With the Amplify Console)}}}

{{{subheading(Build, deploy, and host modern web apps)}}}

#+CINDEX:continuous deployment
#+CINDEX:CDN
Connect your Git repository to continuously deploy your frontend and
backend. Host it on a globally available CDN.

#+CINDEX:repository
1. Connect your repository[fn:13]

   - Github
   - BitBucket
   - GitLab
   - AWS CodeCommit

#+CINDEX:build settings
2. Configure build settings

3. Deploy your app

[[https://aws-amplify.github.io][Amplify Framework]]

** Toolchain

#+CINDEX:toolchain
A powerful [[https://aws-amplify.github.io/media/toolchain][toolchain]] built for developers

#+CINDEX:serverless backends
Effortlessly create and maintain sophisticated serverless backends for your
apps.

#+CINDEX:Amplify Command Line Interface (CLI)
#+CINDEX:Amplify CLI
#+CINDEX:CLI, Amplfy
#+CINDEX:toolchain, unified
#+CINDEX:serverless infrastructure
The Amplify Command Line Interface (CLI) is a unified toolchain to create and
manage your serverless infrastructure on AWS.

*** Effortlessly configure backends

#+CINDEX:serverless backends
#+CINDEX:backends, serverless
#+CINDEX:authentication
#+CINDEX:analytics
#+CINDEX:functions
#+CINDEX:REST
#+CINDEX:GraphQL
#+CINDEX:AWS CloudFormation
#+CINDEX:CloudFormation
#+CINDEX:configurations, add, modify, share
Create sophisticated serverless backends fast. The CLI includes support for
authentication, analytics, functions, REST/GraphQL APIs, and much more. The
toolchain uses AWS CloudFormation and enables you to add, modify, and share
configurations.

#+BEGIN_EXAMPLE
$ cd <your-app>
$ amplify init
$ amplify add <category>
$ amplify push
#+END_EXAMPLE

*** Hosting for static assets and websites

#+CINDEX:content, distribute to end users
#+CINDEX:object storage infrastructure
#+CINDEX:Lambda functions, local testing
#+CINDEX:Lambda functions, connect to APIs
#+CINDEX:deploy, one command
Distribute content to end users with low latency and high data transfer speeds
via a secure, durable, and scalable object storage infrastructure. You can
perform local testing of AWS Lambda functions, connect them to your APIs, and
deploy everything in one command.

#+BEGIN_EXAMPLE
$ amplify add hosting
$ amplify publish
#+END_EXAMPLE

*** Easily create APIs and generate client code

#+CINDEX:GraphQL Scheme Definition language (SDL)
#+CINDEX:SDL
#+CINDEX:CloudFormation template
#+CINDEX:data model, implement
Define your API using the GraphQL Schema Definition Language (SDL). The
toolchain will expand and transform a full CloudFormation template that
implements your data model.

#+BEGIN_EXAMPLE
$ amplify codegen add
$ amplify codegen generate
#+END_EXAMPLE

** Amplify CLI

See [[https://aws-amplify.github.io/docs/cli/init][AWS Amplify CLI]]

The AWS Amplify CLI helps you set up

#+CINDEX:IAM user, Amplify CLI
#+CINDEX:profile, Amplify CLI
#+CINDEX:initialize apps, Amplify
#+CINDEX:configurations, Amplify
- an AWS IAM user
- an AWS profile on your local system
- initialize Amplify powered apps with all your defined configurations.


We’ll also walk through steps as to how you could
- share the Amplify generated backend configuration between other frontend projects
- re-use the same backend infrastructure in-between multiple platforms/users.

#+CINDEX:tutorial, AWS Amplify
#+CINDEX:project, Amplify-enabled
In this tutorial, we’ll walk through setting up an Amplify-enabled project and
go into detail as to what happens behind the scenes when doing so. We’ll go
over the following commands:
#+CINDEX:@command{amplify configure}
#+CINDEX:@command{amplify init}
#+CINDEX:@command{amplify configure project}
- {{{command(amplify configure)}}}
- {{{command(amplify init)}}}
- {{{command(amplify configure project)}}}

*** Install the Amplify CLI

#+CINDEX:CLI, install
#+CINDEX:install CLI
[[https://aws-amplify.github.io/docs/cli/init#install-the-cli][Install the CLI]]

#+CINDEX:AWS account, sign up
#+CINDEX:Node.js, install
#+CINDEX:@command{npm}, install
1. [[https://portal.aws.amazon.com/billing/signup?redirect_url=https%253A%252F%252Faws.amazon.com%252Fregistration-confirmation#/start][sign up for an AWS Account]]
2. install Node.js (8.11+) and {{{command(npm)}}} (5.x+)

*** Amplify Configure

#+CINDEX:CLI, configure
#+CINDEX:configure CLI
[[https://aws-amplify.github.io/docs/cli/init#amplify-configure][Amplify configure]]

#+CINDEX:@command{amplify configure}
#+CINDEX:@command{amplify init}, on new projects
#+CINDEX:projects, new, @command{amplify init}
The {{{command(amplify configure)}}} command is a one-time setup step. After
you perform this on your system you only need to run {{{command(amplify
init)}}} going forward on new projects.

#+CINDEX:AWS, set-up, sign-in
#+CINDEX:IAM User, set-up
#+CINDEX:policies, IAM User
#+CINDEX:resources, deploy
#+CINDEX:AWS Profile, create
#+CINDEX:@samp{accessKey}, IAM user
#+CINDEX:@samp{secretKey}, IAM user
#+CINDEX:profile name
#+CINDEX:initialize project, using AWS Profile
The amplify configure step helps you with the following:
- AWS :: Signing up and signing into AWS
- IAM User :: Setting up an IAM user with the appropriate policies for the CLI
              to deploy AWS resources on behalf of the customer.[fn:10]
- AWS Profile :: Creating an AWS Profile on your local system with reference to
                 the =accessKey= and =secretKey= tied to the IAM user created
                 in the above step.

                 This AWS Profile could be given a custom name (by default we
                 name it “default”) and can be used for /initializing/ any
                 number of projects moving forward. *Essentially the AWS
                 profile defines which AWS account and region the AWS resources
                 would be deployed to.*


#+CINDEX:behind the scenes
{{{heading(What happens behind the scenes?)}}}

#+CINDEX:IAM user, created
#+CINDEX:policies, IAM user
#+CINDEX:AWS account
- An *IAM user* is created in your AWS account with the appropriate policies
  required for the CLI to work

  #+CINDEX:AWS Profile, created
  #+CINDEX:@file{~/.aws/config}
  #+CINDEX:profile name, in @file{config} file
- An *AWS Profile* is created on your local machine. If you check your
  {{{file(~/.aws/config)}}} file on your machine, you would observe a region
  associated with your profile name in the following format:

#+BEGIN_EXAMPLE
[profile amplifyprofile]
region=us-east-1
#+END_EXAMPLE

#+CINDEX:@file{~/.aws/credentials} file
#+CINDEX:@samp{accesskey}, AWS profile
#+CINDEX:@samp{aws_access_key}
#+CINDEX:@samp{secretkey}, AWS profile
#+CINDEX:@samp{aws_secret_access_key}
- Similarly, in your {{{file(~/.aws/credentials)}}} file, you would see the
  =accesskey= and =secretkey= associated with your profile in the following
  format:

  #+BEGIN_EXAMPLE
  [amplifyprofile]
  aws_access_key_id=AKIAI6N66xxxxxxxxxxxx
  aws_secret_access_key=4Nmtuxxxxxxxxxxxxxxxxxxxx
  #+END_EXAMPLE


#+CINDEX:new project, initialize
#+CINDEX:initialize new project
#+CINDEX:region, AWS
#+CINDEX:IAM user, profile
When you initialize a new project, the CLI will ask you to select an AWS
profile. Based on upon your selection all the corresponding resources are
deployed to the region and IAM user tied to the selected profile.

*** Amplify Init

#+CINDEX:CLI, initialize
#+CINDEX:initialize CLI
[[https://aws-amplify.github.io/docs/cli/init#amplify-init][Amplify init]]

#+CINDEX:@command{amplify init}
#+CINDEX:initialization step, new project
#+CINDEX:new project, initialize
#+CINDEX:JavaScript project, new, initialize
#+CINDEX:iOS project, new, initialize
#+CINDEX:Android project, new, initialize
#+CINDEX:backend, AWS, connect project to
The {{{command(amplify init)}}} command is a one-time initialization step for
your Amplify-powered cloud app. You run this once for each project (JavaScript,
iOS, or Android) to connect your app with an AWS backend.

#+CINDEX:AWS Profile, select
#+CINDEX:provision cloud resources
#+CINDEX:frontend framework, select
#+CINDEX:frontend configuration
#+CINDEX:build command, build frontend code
This setup helps you with the following:
- Selecting your AWS Profile which would be used to provision cloud resources
  for your app
- Selecting the frontend framework for your app and corresponding frontend
  framework-related configurations (like the build command to build your
  frontend code).

  #+CINDEX:publish app to cloud
  #+CINDEX:build command
  #+CINDEX:@command{amplify run} command
  This information helps the CLI publish the app to the cloud (after executing
  the build command), as well as helping to run the app locally for you to test
  using the {{{command(amplify run)}}} command.

{{{heading(What happens behind the scenes?)}}}

#+CINDEX:CloudFormation stack, deployed
#+CINDEX:parent stack
- A CloudFormation stack is deployed for you (which we like to call the parent
stack)

#+CINDEX:resources, provisioned by parent CloudFormation stack
- The parent CloudFormation stack provisions the following resources:
  #+CINDEX:S3 deployment bucket
  #+CINDEX:bucket, S3 deployment
  - S3 deployment bucket. It is used to store the following contents:
      #+CINDEX:Parent CloudFormation template
    - Parent CloudFormation template
      #+CINDEX:Nested CloudFormation templqtes
    - Nested CloudFormation templates when you add further AWS resources to
      your project.
      #+CINDEX:Lambda Zip files
      #+CINDEX:API Gateway
      #+CINDEX:Lambda services
    - Lambda Zip files (which are used when using API Gateway & Lambda services
      in your project)
      #+CINDEX:AppSync scheme, resolver files
    - AppSync schema and resolver files
  #+CINDEX:Auth Role
  #+CINDEX:Unauth Role
  #+CINDEX:policies, roles, populated
  - Auth & Unauth Role with no policies in it during the initialization
    phase. The policies get populated in it eventually, based on your
    permission/authorization selections when adding resources to your project
    like API, Storage, and Analytics

#+CINDEX:@file{amplify/} directory, created
- An {{{file(amplify/)}}} directory gets created at the root of your project
  with the following structure:

  #+BEGIN_EXAMPLE
  <project-root>
    |_amplify/
    |_ #current-cloud-backend/
        |_ amplify-meta.json
    |_ .config
        |_ local-aws-info.json
        |_ local-env-info.json
        |_ project-config.json
    |_ backend/
        |_amplify-meta.json
    |_team-provider-info.json
  #+END_EXAMPLE

  #+CINDEX:@file{amplify/backend} directory
  #+CINDEX:backend configuration
  #+CINDEX:CloudFormation templates
  #+CINDEX:@command{amplify add <category>} command
  #+CINDEX:@file{back-config.json} file
  #+CINDEX:backend infrastructure
  #+CINDEX:@file{amplify-meta.json} file
  #+CINDEX:metadata
- The {{{file(amplify/backend)}}} directory contains all the local changes to
  your backend configurations–such as the CloudFormation templates---when you
  add resources to your project using the {{{command(amplify add <category>)}}}
  command. It contains the {{{file{backend-config.json)}}} file which is a
  structure to represent your backend infrastructure and certain CLI runtime
  files like the {{{file(amplify-meta.json)}}} file which contains all the
  metadata tied to your resources which you add via the Amplify CLI.

  #+CINDEX:@file{#current-cloud-backend} directory
  #+CINDEX:@file{backend} directory
  #+CINDEX:@command{amplify push} command
- The {{{file(#current-cloud-backend)}}} directory has a similar structure to
  the {{{file(backend)}}} directory. The only differences between it and the
  {{{file(backend)}}} directory are that it has the configurations that reflect
  what resources were deployed in the cloud with your last {{{command(amplify
  push)}}} command and it helps the CLI diff between the configuration of the
  resources already provisioned in the cloud and what is currently in your
  local {{{file(backend)}}} directory (which reflects your local changes).

  #+CINDEX:@file{.config} directory
  #+CINDEX:metadata files
  #+CINDEX:@file{project-config.json} file
  #+CINDEX:app-specific information
- The {{{file(.config)}}} directory consists of the metadata files tied to your
  project. The {{{file(project-config.json)}}} file, which can be safely
  checked into a version control system, represents information specific to the
  app you’re building. For e.g. a sample format shown below reflects the
  framework you’re using for your app:

  #+BEGIN_EXAMPLE
  {
    "projectName": "testapp",
    "javascript": {
        "framework": "react",
        "config": {
            "SourceDir": "src",
            "DistributionDir": "dist",
            "BuildCommand": "npm run-script build",
            "StartCommand": "npm run-script start"
        }
    },
    "providers": [
        "awscloudformation"
    ],
    "frontend": "javascript",
    "version": "1.0"
  }
  #+END_EXAMPLE

#+CINDEX:@file{.config} directory
#+CINDEX:@file{local-aws-info.json} file
#+CINDEX:profile, key pair
#+CINDEX:resources, adding to project
The {{{file(.config)}}} directory also has a {{{file(local-aws-info.json)}}}
file that lets the CLI know which AWS =profile/accesskey-secret key= pair to
use when adding AWS resources to your project.  *Note:* This file should not be
checked into version control since it has information specific to a system on
which the CLI is running on.

If you’re using an AWS profile to initialize your project, the format should be
the following:

#+BEGIN_EXAMPLE
{
    "dev": {
        "configLevel": "project",
        "useProfile": true,
        "profileName": "devprofile"
    },
    "prod": {
        "configLevel": "project",
        "useProfile": true,
        "profileName": "prodprofile"
    }
}
#+END_EXAMPLE

#+CINDEX:@file{local-env-info.json} file
#+CINDEX:@file{.config} directory
#+CINDEX:preferences, user/system
#+CINDEX:configuration preferences
#+CINDEX:@command{amplify configure project} command
The {{{file(local-env-info.json)}}} file present in the {{{file(.config)}}}
directory lets the CLI store user/system preferences which the user inputs when
initializing the Amplify project in his/her system. These configurations could
be later changed using the {{{command(amplify configure project)}}} command.
*Note:* This file should not be checked into version control since it has
information specific to a system on which the CLI is running on.

This file has the following format:

#+BEGIN_EXAMPLE
{
    "projectPath": "/Users/kaustavg/migtest",
    "defaultEditor": "sublime",
    "envName": "dev"
}
#+END_EXAMPLE

#+CINDEX:@file{team-provider-info.json} file
#+CINDEX:deployment related information
#+CINDEX:environments, tied to project
- The {{{file(team-provider-info.json)}}} file consists of deployment-related
  information for all the environments tied to a project which is specifically
  useful and should be checked into a version control system when sharing your
  environments and backend infrastructure within a team. This file isn’t
  required to be shared if you’re publicly sharing your app infrastructure.

  This file has the following format:

  #+BEGIN_EXAMPLE
  {
    "dev": {
        "awscloudformation": {
            "AuthRoleName": "multenvtest-20181115101929-authRole",
            "UnauthRoleArn": "arn:aws:iam::132393967379:role/multenvtest-20181115101929-unauthRole",
            "AuthRoleArn": "arn:aws:iam::132393967379:role/multenvtest-20181115101929-authRole",
            "Region": "us-east-1",
            "DeploymentBucketName": "multenvtest-20181115101929-deployment",
            "UnauthRoleName": "multenvtest-20181115101929-unauthRole",
            "StackName": "multenvtest-20181115101929",
            "StackId": "arn:aws:cloudformation:us-east-1:132393967379:stack/multenvtest-20181115101929/fc7b1010-e902-11e8-a9bd-50fae97e0835"
        }
    },
    "prod": {
        "awscloudformation": {
            "AuthRoleName": "multenvtest-20181115102119-authRole",
            "UnauthRoleArn": "arn:aws:iam::345090917734:role/multenvtest-20181115102119-unauthRole",
            "AuthRoleArn": "arn:aws:iam::345090917734:role/multenvtest-20181115102119-authRole",
            "Region": "us-east-1",
            "DeploymentBucketName": "multenvtest-20181115102119-deployment",
            "UnauthRoleName": "multenvtest-20181115102119-unauthRole",
            "StackName": "multenvtest-20181115102119",
            "StackId": "arn:aws:cloudformation:us-east-1:345090917734:stack/multenvtest-20181115102119/3e907b70-e903-11e8-a18b-503acac41e61"
        }
  }
  #+END_EXAMPLE

*** Amplify Configure Project

#+CINDEX:project, configure
#+CINDEX:configure project
[[https://aws-amplify.github.io/docs/cli/init#amplify-configure-project][Amplify configure project]]

*** Assuming an IAM Role

#+CINDEX:IAM role, assume
#+CINDEX:assume IAM role
#+CINDEX:role, IAM
[[https://aws-amplify.github.io/docs/cli/init#assuming-an-iam-role][Assuming an IAM Role]]

** UI Components

A beautiful component library connected to the cloud

Accelerate app development by leveraging our beautiful out-of-the box UI
components.

** Tutorial

[[https://www.youtube.com/watch?v=uiTQL7Ne8rY][AWS Amplify React Tutorial]] by the author.
* Amplify Console
:PROPERTIES:
  :APPENDIX: t
  :END:

- [[https://aws.amazon.com/amplify/console/][MAIN SITE]]
- [[https://docs.aws.amazon.com/amplify/latest/userguide/welcome.html][DOCUMENTATION]]

{{{heading(Scalable hosting for static web apps with serverless backends)}}}

#+CINDEX:Amplify Console
#+CINDEX:continuous deployment and hosting service
#+CINDEX:mobile web applications
The AWS Amplify Console is a continuous deployment and hosting service for
mobile web applications. The AWS Amplify Console makes it easier for you to
rapidly release new features, helps you avoid downtime during application
deployment, and handles the complexity of simultaneously updating the frontend
and backend of your applications.

#+CINDEX:application release cycle
#+CINDEX:connect Amplify to code repos
The Amplify Console accelerates your application release cycle minimizing
downtime.  *You just connect Amplify to your code repository and your frontend
and backend are deployed in a single workflow on every code commit.* This
ensures your web application is only updated once the deployment is
successfully completed, eliminating inconsistencies between your application
frontend and backend.

#+CINDEX:Amplify console, launched
#+CINDEX:deploy Amplify applications, preferred method
#+CINDEX:atomic deployments
#+CINDEX:documentation at Amplify
We've [Amazon] recently launched the Amplify Console, which is now the
preferred way of deploying Amplify applications and has built-in CI / CD &
atomic deployments. For more info, check out the documentation at
https://aws.amazon.com/amplify/console/.

{{{subheading(Amplify Framework and the Amplify Console)}}}

#+CINDEX:Amplify Framework
The AWS Amplify Console can be used with Single Page Apps (SPA) and static
sites, whether or not they use the open source Amplify Framework.  The AWS
Amplify Console can deploy apps built with the Amplify Framework.

#+CINDEX:command-line interface, Amplify
#+CINDEX:CLI, Amplify
#+CINDEX:backend resources, serverless, Amplify
#+CINDEX:GraphQL
#+CINDEX:REST
#+CINDEX:AppSync
#+CINDEX:API Gateway
#+CINDEX:Lambda
#+CINDEX:authentication
#+CINDEX:Cognito
The Amplify Framework provides a command-line interface (CLI) and library for
simplifying serverless web and mobile development. The CLI provisions
serverless backend resources (e.g., GraphQL APIs with AWS AppSync, REST APIs
with Amazon API Gateway and AWS Lambda, and authentication with Amazon Cognito)
and the library helps with integrating these backend resources in the frontend.

If you are using the Amplify Framework’s CLI to configure backend resources for
your app, /the AWS Amplify Console can provision/update these for you on each
check-in you make to source control, prior to deploying your frontend./ There
is support for a variety of configurations, such as an isolated backend
deployment per branch.

{{{subheading(Features)}}}

#+CINDEX:content delivery network
#+CINDEX:globally available
- Globally available ::
     Your app is served via Amazon's reliable content delivery network with 144
       points of presence globally.

#+CINDEX:domain setup, custom
#+CINDEX:Route 53
#+CINDEX:HTTPS certificate
- Easy custom domain setup ::
     Set up custom domains managed in Amazon Route 53 with a single click plus
     get a free HTTPS certificate.

#+CINDEX:continuous workflows
#+CINDEX:git repo connection
#+CINDEX:@code{git push} changes
- Simplified continuous workflows ::
     Connect your repository to 'git push' changes to your frontend and backend
     in a single workflow.

#+CINDEX:branch deployments
#+CINDEX:feature branch deployments
#+CINDEX:deployments, features
- Feature branch deployments ::
     Work on new features without impacting production. Create branch
     deployments linked to each feature branch.

#+CINDEX:atomic deployments
#+CINDEX:deployments, atomic
- Atomic deployments ::
     All deployments either rollout successfully or fail without requiring
     maintenance windows.

#+CINDEX:password protection
#+CINDEX:access authentication
- Password protection ::
     Share yet-to-be released features with internal stakeholders by setting a
     username and password.

     All web deployments can be password protected with basic access
     authentication. When working on new features, developers can share updates
     with internal stakeholders by setting up a username and password for a
     branch deployment.

** How It Works

#+CINDEX:single page web apps
#+CINDEX:static sites with serverless backends
#+CINDEX:continuous deployment
#+CINDEX:@indicateurl{amplifyapp.com} subdomain
#+CINDEX:custom domain
#+CINDEX:domain, custom
AWS Amplify Console provides a complete workflow for developing, deploying, and
hosting single page web apps or static sites with serverless
backends. Continuous deployment allows developers to deploy updates to their
web app on every code commit to their Git repository. When the build succeeds,
the app is deployed and hosted on an ~amplifyapp.com~ subdomain. Developers can
connect their custom domain to start receiving production traffic.

#+CINDEX:modern web apps
Modern web apps offer native app-like user experience by serving the app
frontend, or user interface, efficiently to browsers as prebuilt
HTML/JavaScript files that can then invoke backend functionality without
reloading the page. /The Amplify Console provides a complete workflow for
deploying these apps./

To get started, go to the AWS Amplify Console and connect your source
repository.  The AWS Amplify Console automatically determines the *frontend
framework* used, and then builds and deploys the app to a globally available
content delivery network (CDN).  The Console detects *backend functionality*
added using the Amplify Framework, and can deploy the necessary AWS resources
in the same deployment as the frontend.  The AWS Amplify Console will *build
and deploy* your web app quickly, and host your web app on a globally available
CDN with a friendly URL (example:
@@texinfo:@indicateurl{https://master.appname.amplifyapp.com}@@).

1. Connect your repository

   You can connect private and public repositories from GitHub, BitBucket,
   GitLab, and AWS CodeCommit.

2. Configure build settings

   #+CINDEX:environment variables
   #+CINDEX:configurations required at runtime
   Environment variables are configurations required by apps at runtime. These
   configurations could include database connection details, third-party API
   keys, different customization parameters and secrets. The best way to expose
   these configurations is to do so with environment variables. You can add
   environment variables when creating an app or by going to the app
   settings. All environment variables are encrypted to prevent rogue access.

   #+CINDEX:build run
   #+CINDEX:compute container, temporary
   #+CINDEX:CloudWatch
   On a build run, AWS Amplify Console will create a temporary compute
   container (4 vCPU, 7GB RAM), download the source code, execute the commands
   configured in the project, deploy the generated artifact to a web hosting
   environment, and then destroy the compute container. During the build, the
   AWS Amplify Console will stream the build output to the service console and
   Amazon CloudWatch

3. Deploy your app

   #+CINDEX:single page apps
   #+CINDEX:SPAs
   #+CINDEX:React
   #+CINDEX:Angular
   #+CINDEX:Vue
   #+CINDEX:Ember
   #+CINDEX:static sites
   #+CINDEX:Gatsby
   #+CINDEX:Eleventy
   #+CINDEX:Hugo
   #+CINDEX:VuePress
   #+CINDEX:Jekyll
   You can deploy Single page apps (SPAs) built with frameworks like React,
   Angular, Vue, Ember; and static sites generated with frameworks like Gatsby,
   Eleventy, Hugo, VuePress, and Jekyll. You can also host simple static sites.

#+CINDEX:Amplify Console app
#+CINDEX:app, Amplify Console
#+CINDEX:project container
#+CINDEX:app project
#+CINDEX:feature branches
#+CINDEX:custom domain
#+CINDEX:build logs
An AWS Amplify Console 'app' is your project container. Each app project
contains a list of branches you have connected from your source repository. You
can connect additional feature branches, a custom domain, or access your build
logs from your app project.

** Use cases

{{{heading(Build Web Apps with Static and Dynamic Functionality)}}}

#+CINDEX:single page app
#+CINDEX:SPA
#+CINDEX:frameworks
#+CINDEX:React framework
#+CINDEX:Angular framework
#+CINDEX:Vue.js framework
#+CINDEX:Ionic framework
#+CINDEX:Ember framework
#+CINDEX:static site generators
#+CINDEX:Gatsby
#+CINDEX:Eleventy
#+CINDEX:Hugo
#+CINDEX:VuePress
#+CINDEX:Jekyll
AWS Amplify Console supports all Single Page App (SPA) frontend frameworks
(e.g. React, Angular, Vue.js, Ionic, Ember), as well as static-site generators
like Gatsby, Eleventy, Hugo, VuePress, and Jekyll.

#+CINDEX:blogs
#+CINDEX:static web apps
#+CINDEX:web apps, static
#+CINDEX:apps, static web
#+CINDEX:SSL, free
- Blogs or static web apps ::
     Use static site generators like Hugo or Jekyll to publish a blog. SSGs
     perform faster than traditional websites. Deploy SSGs with free SSL on the
     AWS Amplify Console.

#+CINDEX:GraphQL
#+CINDEX:REST
- Serverless web apps ::
     Add dynamic functionality using GraphQL or REST APIs. Use AWS Amplify
     Console to deploy your frontend and backend in a single workflow.

#+CINDEX:progressive web apps
#+CINDEX:web apps, progressive
#+CINDEX:apps, progressive web
#+CINDEX:push notifications
- Progressive web apps ::
     PWAs offer native app-like performance, work offline, support push
     notifications, and can be updated over-the-air.  Use AWS Amplify to deploy
     PWAs to mobile devices.

** Continuous Deployment

#+CINDEX:continuous deployment
Continuous deployment is a devops strategy for software releases where every
code commit to a repository is automatically released to production or staging
environment. This practice reduces time to market by ensuring that your hosted
web app is always a reflection of the latest code in your repository.

** Hosting

#+CINDEX:hosting
#+CINDEX:CloudFront Global Edge Network
#+CINDEX:Points of Presence
Hosting a modern web app does not require web servers and can use content
delivery networks to store static content (HTML, CSS and JavaScript files). The
AWS Amplify Console leverages the Amazon CloudFront Global Edge Network to
distribute your web app globally. To deliver content to end users with lower
latency, Amazon CloudFront uses a global network of 144 Points of Presence (133
Edge Locations and 11 Regional Edge Caches) in 65 cities across 29 countries.

*** Connecting a Domain

#+CINDEX:Route53
#+CINDEX:connecting a domain
#+CINDEX:domain, connecting
#+CINDEX:DNS records, configure
#+CINDEX:subdomains, automatic creation
#+CINDEX:HTTPS certificate
If your domain is registered on Route53, simply pick it from a dropdown and Aws
Amplify Console will automatically configure the DNS records to point the apex
and ‘www’ subdomain to your website.  Additionally, we automatically create
subdomains for all branches that are connected. For example, connecting a ‘dev’
branch creates a deployment at
@@texinfo:@indicateurl{https://dev.appname.amplifyapp.com}@@. As part of the
custom domain setup, we generate a free HTTPS certificate to ensure traffic to
your site is secure.

#+CINDEX:domain registrars
#+CINDEX:3rd party registrars
#+CINDEX:registrars, domain, 3rd party
#+CINDEX:Route53 registrar
Domains purchased through all domain registrars can be connected to an app by
defining a custom domain. For developers using Amazon Route53 as their
registrar, AWS Amplify Console automatically updates the DNS records to point
to their deployed app. For 3rd party registrars, AWS Amplify Console provides
instructions on how to update their DNS records.

*** Secure Traffic over HTTPS

#+CINDEX:HTTPS certificate
#+CINDEX:Route53 domains, HTTPS
#+CINDEX:Amazon Certificate Manager (ACM)
#+CINDEX:ACM, Amazon Certificate Manager
#+CINDEX:SSL/TLS certificates
#+CINDEX:wildcard domain support
AWS Amplify Console generates a free HTTPS on all sites and will enable it
automatically on all Route53-managed domains. The SSL certificate is generated
by Amazon Certificate Manager and has wildcard domain support. ACM handles the
complexity of creating and managing public SSL/TLS certificates for your AWS
based websites and applications. With the wildcard option, the main domain and
all subdomains can be covered by a single certificate.

** Pricing

#+CINDEX:pricing, Amplify Console
#+CINDEX:build & deploy feature, price
#+CINDEX:hosing feature, price
AWS Amplify Console is priced for two features – build & deploy, and hosting.

- build & deploy feature: ::
     the price per build minute is $0.01.

- hosting feature: ::
     the price per GB served is $0.15 and price per GB stored is $0.023.


#+CINDEX:Free Usage Tier
With the AWS Free Usage Tier, you can get started for free. Upon sign up, new
AWS customers receive 1,000 build minutes per month for the build and deploy
feature, and 15 GB served per month and 5 GB data storage per month for the
hosting feature.

* Cognito
:PROPERTIES:
:APPENDIX: t
:END:

{{{heading(Simple and Secure User Sign-Up, Sign-In, and Access Control)}}}

#+CINDEX:user sign-up, sign-in
#+CINDEX:access control to apps
#+CINDEX:social identity providers
#+CINDEX:Facebook
#+CINDEX:Google
#+CINDEX:Amazon
#+CINDEX:SAML 2.0
Amazon Cognito lets you add user sign-up, sign-in, and access control to your
web and mobile apps quickly and easily. Amazon Cognito scales to millions of
users and supports sign-in with social identity providers, such as Facebook,
Google, and Amazon, and enterprise identity providers via SAML 2.0.

- [[https://aws.amazon.com/cognito/][Amazon Cognito Home]]

{{{subheading(Secure and scalable user directory)

#+CINDEX:Amazon Cognito User Pools
#+CINDEX:user directory
#+CINDEX:User Pools
Amazon Cognito User Pools provide a secure user directory that scales to
hundreds of millions of users. As a fully managed service, User Pools are easy
to set up without any worries about standing up server infrastructure.

{{{subheading(Social and enterprise identity federation)}}}

#+CINDEX:social identity providers for sign-in
#+CINDEX:enterprise identity providers
#+CINDEX:Microsoft Active Directory
#+CINDEX:SAML
With Amazon Cognito, your users can sign in through social identity providers
such as Google, Facebook, and Amazon, and through enterprise identity providers
such as Microsoft Active Directory via SAML.

{{{subheading(Standards-based authentication)}}}

#+CINDEX:standards-based Identity Provider
#+CINDEX:Identity Provider, standards-based
#+CINDEX:OAuth 2.0
#+CINDEX:SAML 2.0
#+CINDEX:OpenID Connect
Amazon Cognito User Pools is a standards-based Identity Provider and supports
identity and access management standards, such as Oauth 2.0, SAML 2.0, and
OpenID Connect.

{{{subheading(Security for your apps and users)}}}

#+CINDEX:multi-factor authentication
#+CINDEX:encryption
#+CINDEX:HIPAA eligible
#+CINDEX:PCI DSS
#+CINDEX:SOC
#+CINDEX:ISO/EIC 27001, 27017, 27018
#+CINDEX:ISO 9001
Amazon Cognito supports multi-factor authentication and encryption of
data-at-rest and in-transit. Amazon Cognito is HIPAA eligible and PCI DSS, SOC,
ISO/EIC 27001, ISO/EIC 27017, ISO/EIC 27018, and ISO 9001 compliant.

{{{subheading(Access control for AWS resources)}}}

#+CINDEX:backend resources, access to
#+CINDEX:resources, access to backend
#+CINDEX:roles, define
Amazon Cognito provides solutions to control access to backend resources from
your app. You can define roles and map users to different roles so your app can
access only the resources that are authorized for each user.

{{{subheading(Easy integration with your app)}}}

#+CINDEX:federating identity providers
#+CINDEX:user sign-in, sign-up
#+CINDEX:branding
With a built-in UI and easy configuration for federating identity providers,
you can integrate Amazon Cognito to add user sign-in, sign-up, and access
control to your app in minutes. You can customize the UI to put your company
branding front and center for all user interactions.

{{{heading(Pay only for what you use. No minimums.)}}}

#+CINDEX:payment, Amazon Cognito
#+CINDEX:User Pool, cost
#+CINDEX:cost, User Pool
#+CINDEX:cost, Amazon Cognito
#+CINDEX:monthly active users (MAUs)
#+CINDEX:MAUs
#+CINDEX:user, MAU
If you are using Amazon Cognito Identity to create a User Pool, you pay based
on your monthly active users (MAUs) only. A user is counted as a MAU if, within
a calendar month, there is an identity operation related to that user, such as
sign-up, sign-in, token refresh, or password change. You are not charged for
subsequent sessions or for inactive users within that calendar month.

Free for first 50,000 MAUs.

For users who sign in through SAML or OIDC federation, the price for MAUs above
the 50 MAU free tier is $0.015 per MAU. Using the Federated Identities feature
to get AWS credentials for authenticated or guest users is always free with
Amazon Cognito.

Read more about [[https://aws.amazon.com/cognito/pricing/][our pricing here]].

** Amazon Cognito Features

*** A directory for all your apps and users

#+CINDEX:user directory
#+CINDEX:User Pools
#+CINDEX:user profiles
#+CINDEX:authentication tokens
#+CINDEX:federated users
Amazon Cognito User Pools provide a secure user directory that scales to
hundreds of millions of users. As a fully managed service, User Pools are easy
to set up without any worries about server infrastructure. User Pools provide
user profiles and authentication tokens for users who sign up directly and for
federated users who sign in with social and enterprise identity providers.

#+CINDEX:social identity federation, providers
#+ATTR_TEXINFO: :indic b
- Social and enterprise identity federation ::
     With Amazon Cognito, your users can sign-in through social identity
     providers such as Google, Facebook, and Amazon, and through enterprise
     identity providers such as Microsoft Active Directory using SAML.

#+CINDEX:roles
#+CINDEX:access control, roles
- Access control for AWS resources ::
     Amazon Cognito provides solutions to control access to AWS resources from
     your app. You can define roles and map users to different roles so your
     app can access only the resources that are authorized for each user.

#+CINDEX:authentication
#+CINDEX:OAuth 2.0
#+CINDEX:SAML 2.0
- Standards-based authentication ::
     Amazon Cognito uses common identity management standards including OpenID
     Connect, OAuth 2.0, and SAML 2.0.

*** Built-in customizable UI to sign in users

#+CINDEX:UI for user sign-up, sign-in
#+CINDEX:user sign-up, sign-in, UI
#+CINDEX:SKDs, Android, iOS, JavaScript
Amazon Cognito provides a built-in and customizable UI for user sign-up and
sign-in. You can use Android, iOS, and JavaScript SDKs for Amazon Cognito to
add user sign-up and sign-in pages to your apps.

*** Advanced security features to protect your users

#+CINDEX:security features
#+CINDEX:protect access to user accounts
#+CINDEX:risk-based adaptive authentication
#+CINDEX:compromised credentials
Using advanced security features for Amazon Cognito helps you protect access to
user accounts in your applications. These advanced security features provide
risk-based adaptive authentication and protection from the use of compromised
credentials. With just a few clicks, you can enable these advanced security
features for your Amazon Cognito User Pools.

#+CINDEX:adaptive authentication
#+CINDEX:SMS
#+CINDEX:Time-based One-time Password (TOTP)
#+CINDEX:TOTP
#+CINDEX:Google Authenticator
#+ATTR_TEXINFO: :indic b
- Adaptive authentication ::
     Using advanced security features for Amazon Cognito to add adaptive
     authentication to your applications helps protect your applications’ user
     accounts and user experience. When Amazon Cognito detects unusual sign-in
     activity, such as sign-in attempts from new locations and devices, it
     assigns a risk score to the activity and lets you choose to either prompt
     users for additional verification or block the sign-in request. Users can
     verify their identities using SMS or a Time-based One-time Password (TOTP)
     generator, such as Google Authenticator.

#+CINDEX:compromised credentials
- Protection from compromised credentials ::
     Advanced security features for Amazon Cognito helps protect your
     application users from unauthorized access to their accounts using
     compromised credentials. When Amazon Cognito detects users have entered
     credentials that have been compromised elsewhere, it prompts them to
     change their password.

- Supports Multiple Compliance Programs ::
     Amazon Cognito helps you meet multiple security and compliance
     requirements, including those for highly regulated organizations such as
     healthcare companies and merchants. Amazon Cognito is HIPAA eligible and
     PCI DSS, SOC, and ISO/IEC 27001, ISO/EIC 27017, ISO/EIC 27018, and ISO
     9001 compliant.

** Scenarios from Amazon Cognito

#+CINDEX:scenarios, Amazon Cognito
#+CINDEX:Amazon Cognito scenarios
#+CINDEX:Cognito scenarios
This topic describes six common scenarios for using Amazon Cognito.

The two main components of Amazon Cognito are
- user pools and
- identity pools.


#+CINDEX:user pools
#+CINDEX:directory profile
/User pools/ are user directories that provide sign-up and sign-in options for
your web and mobile app users.  Your app users can sign in either directly
through a user pool, or federate through a third-party identity provider
(IdP). The user pool manages the overhead of handling the tokens that are
returned from social sign-in through Facebook, Google, and Amazon, and from
OpenID Connect (OIDC) and SAML IdPs.  Whether your users sign in directly or
through a third party, all members of the user pool have a directory profile
that you can access through an SDK.

#+CINDEX:identity pools
#+CINDEX:temporary credentials
#+CINDEX:anonymous guest users
#+CINDEX:users, anonymous
/Identity pools/ provide AWS credentials to grant your users access to other
AWS services.  With an identity pool, your users can obtain temporary AWS
credentials to access AWS services, such as Amazon S3 and DynamoDB. Identity
pools support anonymous guest users, as well as federation through third-party
IdPs.

*** Authenticate with a User Pool

#+CINDEX:authenticate with user pool
You can enable your users to authenticate with a user pool. Your app users can
sign in either directly through a user pool, or federate through a third-party
identity provider (IdP). The user pool manages the overhead of handling the
tokens that are returned from social sign-in through Facebook, Google, and
Amazon, and from OpenID Connect (OIDC) and SAML IdPs.

#+CINDEX:pool tokens
#+CINDEX:AWS credentials
After a successful authentication, your web or mobile app will receive user
pool tokens from Amazon Cognito. You can use those tokens to retrieve AWS
credentials that allow your app to access other AWS services, or you might
choose to use them to control access to your server-side resources, or to the
Amazon API Gateway.

For more information, see

- [[https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-authentication-flow.html][User Pool Authentication Flow]]
- [[https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-tokens-with-identity-providers.html][Using Tokens with User Pools]]

*** Access Your Server-side Resources with a User Pool

#+CINDEX:user pool tokens
#+CINDEX:server-side resources, access
#+CINDEX:permissions
After a successful user pool sign-in, your web or mobile app will receive user
pool tokens from Amazon Cognito. You can use those tokens to control access to
your server-side resources. You can also create user pool groups to manage
permissions, and to represent different types of users.

For more information on using groups to control access your resources see:
- [[https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-pools-user-groups.html][Adding Groups to a User Pool]].

#+CINDEX:hosted web UI
#+CINDEX:sign-up, sign-in pages in app
#+CINDEX:OAuth 2.0
#+CINDEX:resource server
#+CINDEX:protected resources, access
Once you configure a domain for your user pool, Amazon Cognito provisions a
hosted web UI that allows you to add sign-up and sign-in pages to your
app. Using this OAuth 2.0 foundation you can create your own resource server to
enable your users to access protected resources.

For more information see:
- [[https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-pools-define-resource-servers.html][Defining Resource Servers for Your User Pool]]

#+CINDEX:user pool authentication
#+CINDEX:authentication, user pool
For more information about user pool authentication see:
- [[https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-authentication-flow.html][User Pool Authentication Flow]]
- [[https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-tokens-with-identity-providers.html][Using Tokens with User Pools]]

*** Access Resources with API Gateway and Lambda with a User Pool

#+CINDEX:API Gateway
You can enable your users to access your API through API Gateway. API Gateway
validates the tokens from a successful user pool authentication, and uses them
to grant your users access to resources including Lambda functions, or your own
API.

#+CINDEX:user pool groups
#+CINDEX:groups
You can use groups in a user pool to control permissions with API Gateway by
mapping group membership to IAM roles. The groups that a user is a member of
are included in the ID token provided by a user pool when your app user signs
in.

For more information on user pool groups, see:
- [[https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-pools-user-groups.html][Adding Groups to a User Pool]]

  #+CINDEX:Lambda function
You can submit your user pool tokens with a request to API Gateway for
verification by an Amazon Cognito authorizer Lambda function.

For more information on API Gateway, see:
- [[https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-integrate-with-cognito.html][Using API Gateway with Amazon Cognito User Pools]]

*** Access AWS Services with a User Pool and an Identity Pool

#+CINDEX:AWS services, access, identity pool
After a successful user pool authentication, your app will receive user pool
tokens from Amazon Cognito. You can exchange them for temporary access to other
AWS services with an identity pool.

For more information, see
- [[https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-integrating-user-pools-with-identity-pools.html][Accessing AWS Services Using an Identity Pool After Sign-in]]
- [[https://docs.aws.amazon.com/cognito/latest/developerguide/getting-started-with-identity-pools.html][Getting Started with Amazon Cognito Identity Pools (Federated Identities)]]

*** Authenticate with a Third Party and Access AWS Services with an Identity Pool

#+CINDEX:IdP token
You can enable your users access to AWS services through an identity pool. An
identity pool requires an IdP token from a user that's authenticated by a
third-party identity provider (or nothing if it's an anonymous guest). In
exchange, the identity pool grants temporary AWS credentials that you can use
to access other AWS services.

For more information, see:
- [[https://docs.aws.amazon.com/cognito/latest/developerguide/getting-started-with-identity-pools.html][Getting Started with Amazon Cognito Identity Pools (Federated Identities)]]

*** Access AWS AppSync Resources with Amazon Cognito

#+CINDEX:AWS AppSync
#+CINDEX:AppSync
You can grant your users access to AWS AppSync resources with tokens from a
successful Amazon Cognito authentication (from a user pool or an identity
pool).

For more information, see
- [[https://docs.aws.amazon.com/appsync/latest/devguide/security.html][Access AWS AppSync and Data Sources with User Pools or Federated Identities]]

** Getting Started with Amazon Cognito

- [[https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-getting-started.html][Getting Started]]

This section describes the top Amazon Cognito tasks and where to start.

#+CINDEX:user pools
#+CINDEX:identity pools
The two main components of Amazon Cognito are /user pools/ and /identity
pools/.

- {{{dfn(User Pools)}}} ::
     are user directories that provide sign-up and sign-in options for your web
     and mobile app users.

- {{{dfn(Identity Pools)}}} ::
     provide AWS credentials to grant your users access to other AWS services.


You can use user pools and identity pools separately or together.

{{{heading(Top Tasks and Where to Start)}}}

{{{subheading(Add Sign-up and Sign-in with a User Pool)}}}

#+CINDEX:user directory
#+CINDEX:user pool
#+CINDEX:hosted UI
#+CINDEX:social sign-in
#+CINDEX:SAML-based identity provider sign-in
#+CINDEX:sign-in
#+CINDEX:OpenID Connect sign-in
#+CINDEX:OIDC sign-in
#+CINDEX:customize UI
#+CINDEX:customize user pool workflows
#+CINDEX:Lambda triggers
#+CINDEX:data
#+CINDEX:Amazon Pinpoint analytics
1. Create a user directory with a user pool.
2. Add an app to enable the hosted UI.
3. Add social sign-in to a user pool.
4. Add sign-in through SAML-based identity providers (IdPs) to a user pool.
5. Add sign-in through OpenID Connect (OIDC) IdPs to a user pool.
6. Install a user pool SDK.
7. Customize the built-in hosted web UI sign-in and sign-up pages.
8. Configure user pool security features.
9. Customize user pool workflows with Lambda triggers.
10. Gather data and target campaigns with Amazon Pinpoint analytics.

{{{subheading(Manage Users in a User Pool)}}}

#+CINDEX:manage users in user pool
1. Sign up and confirm user accounts.
2. Create user accounts as administrator.
3. Manage and search user accounts.
4. Add groups to a user pool.
5. Import users into a user pool.

{{{subheading(Access Resources)}}}

#+CINDEX:access resources
#+CINDEX:authenticate with a user pool
#+CINDEX:user pool, authenticate with
#+CINDEX:backend resources, access
#+CINDEX:API Gateway
#+CINDEX:Lambda
#+CINDEX:API AppSync
#+CINDEX:AWS services, access
1. Authenticate with a user pool.
2. Access backend resources through a user pool.
3. Access API Gateway and Lambda through a user pool.
4. Access AWS services with a user pool and an identity pool.
5. Access AWS services through a third party and an identity pool.
6. Access AWS AppSync resources through a user pool or an identity pool.

*** Amazon Cognito User Pools

You can quickly create your own directory to sign up and sign in users, and to
store user profiles using Amazon Cognito User Pools. User Pools provide a user
interface you can customize to match your app. User Pools also enable easy
integration with social identity providers such as Facebook, Google, and
Amazon, and enterprise identity providers such as Microsoft Active Directory
through SAML.

- [[https://docs.aws.amazon.com/cognito/latest/developerguide/getting-started-with-cognito-user-pools.html][Getting started with User Pools]]

These steps describe setting up and configuring a user pool with the Amazon
Cognito console.

*** Amazon Cognito Federated Identities

#+CINDEX:access control to backend resources
You can control access to your backend AWS resources and APIs through Amazon
Cognito so users of your app get only the appropriate access. You can map users
to different roles and permissions and get temporary AWS credentials for
accessing AWS services such as Amazon S3, Amazon DynamoDB, Amazon API Gateway,
and AWS Lambda.

#+CINDEX:identity pools
Amazon Cognito identity pools enable you to create unique identities and assign
permissions for users. Your identity pool can include:

- Users in an Amazon Cognito user pool

  #+CINDEX:identity providers
  #+CINDEX:Facebook
  #+CINDEX:Google
  #+CINDEX:SAML-based identity provider
- Users who authenticate with external identity providers such as Facebook,
  Google, or a SAML-based identity provider

- Users authenticated via your own existing authentication process


#+CINDEX:temporary AWS credentials
#+CINDEX:Amazon API Gateway
With an identity pool, you can obtain temporary AWS credentials with
permissions you define to directly access other AWS services or to access
resources through Amazon API Gateway.

- [[https://docs.aws.amazon.com/cognito/latest/developerguide/getting-started-with-identity-pools.html][Getting Started with Amazon Cognito Identity Pools]]

** Using Amazon Cognito for Mobile Apps

#+CINDEX:web identity federation, Amazon Cognito
#+CINDEX:Amazon Cognito
#+CINDEX:Cognito
The preferred way to use web identity federation is to use [[https://aws.amazon.com/cognito/][Amazon Cognito]].

#+BEGIN_cartouche
For example, Adele the developer is building a game for a mobile device where
user data such as scores and profiles is stored in Amazon S3 and Amazon
DynamoDB. Adele could also store this data locally on the device and use Amazon
Cognito to keep it synchronized across devices.

She knows that for security and maintenance reasons, long-term AWS security
credentials should not be distributed with the game. She also knows that the
game might have a large number of users. For all of these reasons, she does not
want to create new user identities in IAM for each player.

Instead, she builds the game so that users can sign in using an identity that
they've already established with a well-known external identity provider (IdP),
such as Login with Amazon, Facebook, Google, or any OpenID Connect
(OIDC)-compatible IdP. Her game can take advantage of the authentication
mechanism from one of these providers to validate the user's identity.
#+END_cartouche

{{{heading(Enable Mobile App to Access AWS Resources)}}}

#+CINDEX:developer ID
- To enable the mobile app to access her AWS resources, Adele first registers
  for a developer ID with her chosen IdPs.

- She also configures the application with each of these providers.

  #+CINDEX:IAM roles, create
  #+CINDEX:roles, create IAM
  #+CINDEX:permissions, define
- In her AWS account that contains the Amazon S3 bucket and DynamoDB table for
  the game, Adele uses Amazon Cognito to create IAM roles that precisely define
  permissions that the game needs.

  #+CINDEX:OIDC identity provider
- If she is using an OIDC IdP, she also creates an IAM OIDC identity provider
  entity to establish trust between her AWS account and the IdP.

- In the app's code, Adele calls the sign-in interface for the IdP that she
  configured previously.

  #+CINDEX:OAuth access token
  #+CINDEX:OIDC ID token
- The IdP handles all the details of letting the user sign in, and the app gets
  an OAuth access token or OIDC ID token from the provider.

  #+CINDEX:temporary security credentials, trade with authentication info
- Adele's app can trade this authentication information for a set of temporary
  security credentials that consist of an AWS access key ID, a secret access
  key, and a session token.

  #+CINDEX:limited permissions
  #+CINDEX:permissions, limited
- The app can then use these credentials to access web services offered by AWS.
  The app is limited to the permissions that are defined in the role that it
  assumes.


The following figure shows a simplified flow for how this might work, using
Login with Amazon as the IdP. For Step 2, the app can also use Facebook,
Google, or any OIDC-compatible IdP, but that's not shown here.

#+CINDEX:Cognito login flow
#+NAME:fig:cognito-login
#+CAPTION:Flow for Amazon Cognito LogIn
[[file:img/mobile-app-web-identity-federation.png]]

1. A customer starts your app on a mobile device. The app asks the user to sign
   in.
2. The app uses Login with Amazon resources to accept the user's credentials.
3. The app uses Cognito API operations to exchange the Login with Amazon ID token for a Cognito token.
4. The app requests temporary security credentials from AWS STS, passing the Cognito token.
5. The temporary security credentials can be used by the app to access any AWS
   resources required by the app to operate. The role associated with the
   temporary security credentials and its assigned policies determines what can
   be accessed.


{{{heading(Configure App to Use Amazon Cognito to Authenticate)}}}

#+CINDEX:Amazon Cognito
#+CINDEX:Cognito
#+CINDEX:configure app, Amazon Cognito
#+CINDEX:authenticate users
#+CINDEX:resources, allow to an app
Use the following process to configure your app to use Amazon Cognito to
authenticate users and give your app access to AWS resources. For specific
steps to accomplish this scenario, consult the documentation for Amazon
Cognito.

1. (Optional) Sign up as a  developer with Login with Amazon, Facebook, Google,
   or any other OpenID Connect (OIDC)–compatible  IdP and configure one or more
   apps with  the provider. This step  is optional because Amazon  Cognito also
   supports unauthenticated (guest) access for your users.

2. Go to [[https://console.aws.amazon.com/cognito/home][Amazon Cognito in the AWS Management Console]]. Use the Amazon Cognito
   wizard to create an identity pool, which is a container that Amazon Cognito
   uses to keep end user identities organized for your apps. You can share
   identity pools between apps. When you set up an identity pool, Amazon
   Cognito creates one or two IAM roles (one for authenticated identities, and
   one for unauthenticated "guest" identities) that define permissions for
   Amazon Cognito users.

   #+CINDEX:AWS SDK for iOS, Android
   #+CINDEX:SDK for iOS, Android
3. Download and integrate the [[https://aws.amazon.com/sdkforios/][AWS SDK for iOS]] or the [[https://aws.amazon.com//sdkforandroid/][AWS SDK for Android]] with
   your app, and import the files required to use Amazon Cognito.

4. Create an instance of the Amazon Cognito credentials provider, passing the
   identity pool ID, your AWS account number, and the Amazon Resource Name
   (ARN) of the roles that you associated with the identity pool. The Amazon
   Cognito wizard in the AWS Management Console provides sample code to help
   you get started.

5. When your app accesses an AWS resource, pass the credentials provider
   instance to the client object, which passes temporary security credentials
   to the client. The permissions for the credentials are based on the role or
   roles that you defined earlier.


- [[https://docs.aws.amazon.com/mobile/sdkforandroid/developerguide/cognito-auth.html][Amazon Cognito Identity]] in the AWS Mobile SDK for Android Developer Guide.
- [[https://docs.aws.amazon.com/mobile/sdkforios/developerguide/cognito-auth.html][Amazon Cognito Identity]] in the AWS Mobile SDK for iOS Developer Guide.

** Tutorials for Amazon Cognito

#+CINDEX:tutorials, Amazon Cognito
- [[https://docs.aws.amazon.com/cognito/latest/developerguide/tutorial-create-user-pool.html][Tutorial: Creating a User Pool]]
- [[https://docs.aws.amazon.com/cognito/latest/developerguide/tutorial-create-identity-pool.html][Tutorial: Creating an Identity Pool]]
- [[https://docs.aws.amazon.com/cognito/latest/developerguide/tutorial-cleanup-tutorial.html][Tutorial: Cleaning Up Your AWS Resources]]
- [[https://docs.aws.amazon.com/cognito/latest/developerguide/tutorial-add-apps.html][Tutorial: Adding a Web or Mobile App to a User Pool]]

* AppSync

{{{heading(Store and sync data across mobile and web apps in real-time)}}}

{{{subheading(AWS AppSync is a serverless back-end for mobile, web, and
enterprise applications.)}}}

#+CINDEX:data, store and sync
#+CINDEX:data, mobile and web apps
#+CINDEX:serverless back-end for applications
#+CINDEX:application data management tasks
AWS AppSync makes it easy to build data driven mobile and web applications by
handling securely all the application data management tasks like
- online and offline data access,
- data synchronization, and
- data manipulation across multiple data sources.


#+CINDEX:GraphQL
#+CINDEX:data requirements
AWS AppSync uses GraphQL, an API query language designed to build client
applications by providing an intuitive and flexible syntax for describing their
data requirement.

{{{subheading(Benefits)}}}

#+ATTR_TEXINFO: :indic b
- Start effortlessly; scale with your business ::

     #+CINDEX:AppSync management console
     #+CINDEX:DynamoDB, AppSync
     #+CINDEX:Elasticsearch, AppSync
     #+CINDEX:Lambda, AppSync
     Get started in minutes with the intuitive AWS AppSync management console,
     or use AWS Amplify CLI to automatically generate your API and client-side
     code. AWS AppSync integrates with Amazon DynamoDB, Amazon Elasticsearch,
     and Amazon Lambda, enabling you to create sophisticated applications, with
     virtually unlimited throughput and storage, that scale according to your
     business needs.

- Real-time subscriptions and offline access ::

     #+CINDEX:subscriptions, real-time
     AWS AppSync enables real-time subscriptions across millions of devices, as
     well as offline access to app data. When an offline device reconnects, AWS
     AppSync syncs only the updates that occurred when the device was
     disconnected, and not the entire database. AWS AppSync offers
     user-customizable server-side conflict resolution that does the heavy
     lifting of managing data conflicts so you don’t have to.

- Unify and secure access to your distributed data ::

     #+CINDEX:queries
     #+CINDEX:aggregation
     Perform complex queries and aggregation across your on-premise or cloud
     data sources using GraphQL. AWS AppSync makes it easy to secure your app
     data using powerful fine-grained access controls.


{{{subheading(How It Works)}}}

  #+CINDEX:schema, AppSync
- Create schema ::

                   #+CINDEX:GraphQL API using console editor
                   Developers use the console editor to define and deploy a
                   GraphQL API so the application can query and change data and
                   update in real time.

- AppSync ::

             #+CINDEX:resources, automatic provisioning, AppSync
             Automatically provisions data sources and compute resources, or
             uses existing resources, and connects them to your GraphQL API.

- Offline ::

             #+CINDEX:offline use, AppSync
             Client applications make GraphQL API calls to fetch data, make
             changes, or subscribe to changes in real time from all users and
             devices.  Offline users can continue to access and change app data
             and get updates when they are connected.


#+CINDEX:video, @cite{re:Invent}
#+CINDEX:AppSync console
#+CINDEX:console, AppSync
AWS AppSync is generally available. If you would like try building data driven
mobile and web applications, watch the [[https://img.youtube.com/vi/FtkVlIal_m0/0.jpg][re:Invent session video]] to learn more
and [[http://console.aws.amazon.com/appsync/home][open the AWS AppSync console]] to get started.


{{{subheading(Use Cases)}}}

#+CINDEX:use cases, AppSync
#+CINDEX:AppSync use cases
#+CINDEX:real-time data updates
#+CINDEX:offline capabilities
AWS AppSync is applicable to all types of mobile and web applications across
industries, verticals, and categories where the apps require real-time data
updates and offline capabilities. Here are some examples of apps that can
particularly benefit from being built with AWS AppSync.

#+ATTR_TEXINFO: :indic b
- Collaboration applications ::

     #+CINDEX:collaboration, AppSync
     AWS AppSync makes it easy to build apps that let multiple users share and
     collaborate on content. AWS AppSync automatically updates data for
     different types of content including documents, images, text messages, and
     shared whiteboards.

- Social media, chat, dating apps ::

     #+CINDEX:social media apps, AppSync
     #+CINDEX:messaging, AppSync
     AWS AppSync is perfect for building social media, chat, and dating
     apps. AWS AppSync can help by managing the messaging among multiple users
     with a variety of data types and sources. With AWS AppSync, users can
     interact with their apps even when they are offline and AWS AppSync will
     update their messages when they reconnect.

- AR and VR training applications ::

     #+CINDEX:virtual reality apps, AppSync
     AWS AppSync can help manage the data for training and teaching
     applications, such as doctors in surgery with observers, or teachers
     giving lessons to students. These types of apps need to support augmented
     and virtual reality (AR and VR) where the data is combined or incorporated
     into other information and needs to be updated in real time during a
     procedure or interactive session like a lesson.

** Features

- GraphQL ::

             Simplified Data Access and Querying

             AWS AppSync uses GraphQL, a data language that enables client apps
             to fetch, change and subscribe to data from servers. In a GraphQL
             query, the client specifies how the data is to be structured when
             it is returned by the server. This makes it possible for the
             client to query only for the data it needs, in the format that it
             needs it in. GraphQL also includes a feature called
             “introspection” which lets new developers on a project discover
             the data available without requiring knowledge of the backend.

- Real-time data access and updates ::

     Immediate updates across clients and devices

     AWS AppSync lets you specify which portions of your data should be
     available in a real-time manner using GraphQL Subscriptions. GraphQL
     Subscriptions are simple statements in the application code that tell the
     service what data should be updated in real-time.

- Offline data synchronization ::

     Interact with and update your data, even when offline

     AWS AppSync supports an offline programming model where application data
     is not only available offline, but users can add and update data as
     well. When the device is offline, the application UI will be automatically
     updated with the offline data. AppSync lets you define how data is cached
     offline as well as how AppSync should manage the cache updates under
     different network conditions.

- Data querying, filtering, and search in apps ::

     Preconfigured access to AWS data sources

     AWS AppSync gives client applications the ability to specify data
     requirements with GraphQL so that only the needed data is fetched,
     allowing for both server and client filtering. Since AWS AppSync supports
     AWS Lambda, Amazon DynamoDB and Amazon Elasticsearch, the GraphQL
     operations can be simple lookups, complex queries & mappings, full text
     searches, fuzzy/keyword searches or geo lookups.

- Enterprise security and fine-grained access control ::

     Control your data

     AWS AppSync allows several levels of data access and authorization
     depending on the needs of an application. Simple access can be protected
     by a key and more restrictive permission can be done with AWS Identity and
     Access Management using Roles. Additionally, AWS AppSync integrates with
     Amazon Cognito User Pools for email and password functionality, social
     providers (Facebook, Google+, and Login with Amazon), and enterprise
     federation with SAML. Customers can use the Group functionality for
     logical organization of users and roles as well as OAuth features for
     application access.

** About

- What is AWS AppSync

  AWS AppSync is a new service that enables developers to manage and
  synchronize mobile app data in real time across devices and users, but still
  allows the data to be accessed and altered when the mobile device is in an
  offline state.

  The service further allows developers to optimize the user experience by
  selecting which data is automatically synchronized to each user's device when
  changes are made, minimizing storage and bandwidth requirements, with a query
  language called GraphQL.

  Using these capabilities, developers can, in minutes, build real time
  collaborative experiences spanning browsers, mobile apps, Alexa skills, and
  IoT devices that remain usable when network connectivity is lost.

- What Types of Apps Can Be Built

  AWS AppSync can be used to build mobile apps that would benefit from being
  able to synchronize user and app data across devices, continue functioning
  when disconnected, and offer real-time collaboration experiences. There are
  applications across all verticals. Examples include:

  - Gaming apps with real-time scoreboards

  - News feeds and financial data

  - Customer service dashboards

  - Shared wallet, travel or itinerary tracking with offline usage

  - Social Media with content feeds and search/discovery/messaging

  - Dating apps with likes, messaging and geo/proximity awareness

  - Field service apps that need to allow for querying and CRUD operations,
    even when disconnected

  - Document collaboration

  - 3D collaboration such as shared whiteboards

  - AR/VR with multiple actors (doctors in surgery with observers, teachers and
    students)

  - Multi-device (e.g., Alexa, mobile, web, IoT) and multi-modal applications
    (e.g., task list) that need to work offline yet reflect the same eventually
    consistent state

  - Chat apps, including presence indicators and conversation history

* List of Figures
:PROPERTIES:
:APPENDIX: t
:END:
#+TEXINFO:@listoffloats Figure

* List of Code
:PROPERTIES:
:APPENDIX: t
:END:
#+TEXINFO: @listoffloats Listing
* Index
  :PROPERTIES:
  :INDEX:    cp
  :END:

* Copying
  :PROPERTIES:
  :COPYING:  t
  :END:

  *{{{title}}}* by {{{author}}}[fn:14]

  \copy 2019

  Outline {{{VERSION}}} by WLHarvey4

* README                                                           :noexport:

  #+BEGIN_SRC markdown :tangle README.md

  # Building Serverless Web Applications with React & AWS Amplify

  ## Author

  Nader Dabit

  ## Date

  February 6, 2019

  ## Source

  [Egghead.io](https://egghead.io/courses/building-serverless-web-applications-with-react-aws-amplify)

  ## Synopsis

  This course walks you through setup and implementation to get your
  cloud-based application up and running.

  * a new project in AWS Amplify configured to your React app
  * user authentication with Amazon Cognito
  * managed GraphQL with AWS AppSync
  * mage storage and retrieval with Amazon S3
  * text translation via Lambda functions
  * and finally, deployment of your application on AWS using Amazon S3

  You’ll finish the course ready to quickly and easily deploy your
  serverless React application, so users can start using and enjoying
  it right away.

  #+END_SRC

* MACRO DEFINITIONS                                                :noexport:
#+MACRO:VERSION Version 0.5.5 <2019-03-01 Fri 09:15>
#+MACRO:OUTLINE Outline by WLHarvey4
#+MACRO:heading @@texinfo:@heading @@$1
#+MACRO:subheading @@texinfo:@subheading @@$1
#+MACRO:file @@texinfo:@file{@@$1@@texinfo:}@@
#+MACRO:dfn @@texinfo:@dfn{@@$1@@texinfo:}@@
#+MACRO:command @@texinfo:@command{@@$1@@texinfo:}@@
#+MACRO:noindent @@texinfo:@noindent @@
#+MACRO:key @@texinfo:@key{@@$1@@texinfo:}@@
#+MACRO:pxref @@texinfo:@pxref{@@$1@@texinfo:}@@
#+MACRO:samp @@texinfo:@samp{@@$1@@texinfo:}@@
* EXPORT SETUP                                                     :noexport:
#+TEXINFO_FILENAME:react-aws-amplify.info
#+TEXINFO_CLASS: info
#+TEXINFO_HEADER:
#+TEXINFO_POST_HEADER:
#+SUBTITLE:
#+SUBAUTHOR:
#+TEXINFO_DIR_CATEGORY:React
#+TEXINFO_DIR_TITLE:React AWS Amplify
#+TEXINFO_DIR_DESC:Building serverless web applications
#+OPTIONS: ':nil *:t -:t ::t <:t H:4 \n:nil ^:t arch:headline
#+OPTIONS: author:t broken-links:nil c:nil creator:nil
#+OPTIONS: d:(not "LOGBOOK") date:t e:t email:nil f:t inline:t num:t
#+OPTIONS: p:nil pri:nil prop:nil stat:t tags:t tasks:t tex:t
#+OPTIONS: timestamp:t title:t toc:t todo:t |:t
#+LANGUAGE: en
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
#+CREATOR: Emacs 26.1 (Org mode 9.1.14)

* Footnotes

[fn:1] The AWS Amplify CLI is a toolchain which includes a robust feature set
for simplifying mobile and web application development. The CLI uses AWS
CloudFormation and nested stacks, which allows you to add or modify
configurations locally before you push them for execution in your account.

[fn:2] An AWS Identity and Access Management (IAM) user is an entity that you
create in AWS to represent the person or application that uses it to interact
with AWS. A user in AWS consists of a name and credentials.

[fn:3] Requires Node.js® version 8.11.x or later

[fn:4] Configures the AWS access credentials, AWS Region and sets up a new AWS
User Profile

[fn:5] Amazon cloud computing resources are hosted in multiple locations
world-wide. These locations are composed of AWS Regions and Availability
Zones. Each AWS Region is a separate geographic area. Each AWS Region has
multiple, isolated locations known as Availability Zones. Amazon RDS provides
you the ability to place resources, such as instances, and data in multiple
locations. Resources aren't replicated across AWS Regions unless you do so
specifically.

[fn:6] [[https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys][Access Keys (Access Key ID and Secret Access Key).]]

[fn:7] [[https://reactjs.org/][React]]; [[https://facebook.github.io/create-react-app/][Create React App]]; [[https://github.com/facebook/create-react-app][GitHub create-react-app]]

[fn:15] NOTE: There is no {{{file(.amplifyrc)}}} file

[fn:9] [[https://aws-amplify.github.io/docs/js/authentication][~withAuthenticator~]]

[fn:8] [[https://aws-amplify.github.io/docs/js/ui][AWS Amplify HOCs]]

[fn:11] An opinionated, category-based client framework for building scalable
mobile and web apps

[fn:12] Verify that you are running at least Node.js version 8.x or greater and
{{{command(npm)}}} version 5.x or greater by running ~node -v~ and ~npm -v~ in
a terminal/console window.

[fn:13] Amplify Console requires read-only access to your repository.

[fn:10] By default we give administrator access to this IAM user since the CLI
needs access to a variety of services for deployments.

[fn:14] Developer Advocate at Amazon Web Services specializing in
cross-platform & cloud-enabled application development.  http://naderdabit.me/

