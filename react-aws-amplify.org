# -*- mode:org; fill-column:79; -*-

#+TITLE:Building Serverless Web Applications with React & AWS Amplify
#+AUTHOR:Nader Dabit
#+DATE:2019-02-06

#+TEXINFO:@insertcopying

* Introduction

  #+CINDEX:course description
  #+CINDEX:React
  #+CINDEX:web application
  #+CINDEX:cloud-based web application
  React makes it intuitive to build real-world web applications.  But in
  reality, you need to use a host of other services to get the app in front of
  real users.  /This course walks you through setup and implementation to get
  your cloud-based application up and running./

  You’ll learn to set up:

  #+CINDEX:AWS Amplify
  #+CINDEX:Amazon Cognito
  #+CINDEX:GraphQL
  #+CINDEX:AWS AppSync
  #+CINDEX:Amazon S3
  #+CINDEX:Lambda functions
  #+CINDEX:deployment using Amazon S3
  - a new project in [[https://aws-amplify.github.io/][AWS Amplify]] configured to your React app
  - user authentication with [[https://aws.amazon.com/cognito/][Amazon Cognito]]
  - manage [[https://graphql.org/][GraphQL]] with [[https://aws.amazon.com/appsync/][AWS AppSync]]
  - image storage and retrieval with [[https://aws.amazon.com/s3/][Amazon S3]]
  - text translation via [[https://aws.amazon.com/lambda/][Lambda functions]]
  - and finally, deployment of your application on AWS using Amazon S3


  #+CINDEX:React application, serverless
  #+CINDEX:serverless React application
  You’ll finish the course ready to quickly and easily deploy your
  serverless React application, so users can start using and enjoying
  it right away.

* Set Up the AWS Amplify CLI

  #+CINDEX:AWS Amplify
  #+CINDEX:Amplify CLI
  #+CINDEX:Amplify, configure project
  #+CINDEX:configure Amplify
  #+CINDEX:IAM user
  #+CINDEX:new project, Amplify
  #+CINDEX:Amplify project, new
  In this lesson we’ll show how to install the [[https://github.com/aws-amplify/amplify-cli][AWS Amplify CLI]] [fn:1] and then
  configure it with an [[https://docs.aws.amazon.com/IAM/latest/UserGuide/id_users.html][IAM user]] [fn:2] so we can begin creating new Amplify projects.

- Install AWS Amplify CLI
- Configure with Amazon IAM user
- Setup Access Keys

** Install and Configure the AWS Amplify CLI

- Install AWS Amplify CLI
- Configure AWS Amplify CLI

   #+CINDEX:CLI, install
   #+CINDEX:install CLI
   #+CINDEX:@command{npm install}
   #+CINDEX:@command{amplify configure}
   #+CINDEX:configure Amplify
   #+CINDEX:AWS console
   #+CINDEX:console, AWS
   #+CINDEX:AWS account
   #+CINDEX:account, AWS
   #+CINDEX:log in, AWS console
   [00:01] To get started, we'll [[https://github.com/aws-amplify/amplify-cli#install-the-cli][install the CLI]] [fn:3] by running:
   : npm install -g @aws-amplify/cli
   {{{noindent}}}Now that the CLI has been installed, we'll run:
   : amplify configure
   #+CINDEX:AWS access credentials
   #+CINDEX:access credentials, AWS
   #+CINDEX:credentials, access, AWS
   {{{noindent}}}to configure the CLI with the user from our AWS account.[fn:4]
   This should open up the AWS console.  Once you're logged into the console,
   jump back to the command-line.

** Setup and Configure AWS IAM User

   #+CINDEX:AWS region
   #+CINDEX:region, AWS
   #+CINDEX:us-east-1, AWS region
   #+CINDEX:username
   #+CINDEX:new user, create
   #+CINDEX:IAM dashboard
   #+CINDEX:dashboard, IAM
   #+CINDEX:AWS account
   #+CINDEX:accountm, AWS
   [00:33] We're next prompted to specify an AWS region. [fn:5] For me, that's
   =us-east-1=.  Now we can give a =username= for the new user that we're about
   to create.  I'll give mine the =username= of ~amplify-egghead-cli-user~.
   This should open up the [[https://aws.amazon.com/iam/][IAM dashboard]] in our [[https://aws.amazon.com/][AWS account]].

   #+CINDEX:IAM user
   #+CINDEX:settings, preconfigured
   #+CINDEX:access key ID
   #+CINDEX:secret access key
   #+CINDEX:keys, access and secret access
   [00:53] This IAM user has some preconfigured settings that we can accept by
   clicking {{{key(Next Permissions)}}}, {{{key(Next Review)}}}, and
   {{{key(Create User)}}}.  Once the user's been created, we're given an
   =access key ID= and a =secret access key=.

** Setup Access Keys

   #+CINDEX:access key ID
   #+CINDEX:secret access key
   [01:16] Copy the =access key ID= to your clipboard, jump back to the
   command-line and paste it into the prompt.  Do the same with the =secret
   access key=. [fn:6]

   #+CINDEX:profile name, set
   #+CINDEX:CLI, configured
   #+CINDEX:AWS Amplify project, initialize
   #+CINDEX:initialize AWS Amplify project
   [01:29] Here we can set a =profile name=. I'll give the =profile name= a
   name of ~amplify-egghead-cli-user~.  Now the CLI has been configured and
   we're ready to begin initializing new AWS Amplify projects.

* Create & Configure an AWS Amplify Project with a React Application

  #+CINDEX:React application, create new
  #+CINDEX:AWS Amplify project, create new
  #+CINDEX:React application, configure
  #+CINDEX:configure, React application
  #+CINDEX:AWS services
  In this lesson we’ll create a new React application, create a new
  AWS Amplify project, & configure the React application to begin
  working with Amplify & AWS services.

  - New React Application
  - New AWS Amplify project
  - Configure Application to Work with AWS Amplify Services

** Create A New React Application

    [00:01] Now that we've installed and configured the CLI, let's
    create a new React application, and then initialize a new Amplify
    project within the React application.

    #+CINDEX:@command{create-react-app}
    #+CINDEX:React application, create new
    [00:14] To do so, we'll use {{{command(create-react-app)}}}[fn:7] to create
    a [[https://reactjs.org/docs/create-a-new-react-app.html][new React application]] called ~MyAmplify.app~.  Once the new React
    application has been created, let's change into the new directory.

** Initialize A New Amplify Project

   #+CINDEX:@command{amplify init}
   #+CINDEX:Amplify project, initialize
   #+CINDEX:initialize, Amplify project
   #+CINDEX:options, Amplify project
   #+CINDEX:editor, default
   #+CINDEX:default editor, Amplify project
   #+CINDEX:JavaScript, app type
   #+CINDEX:app, JavaScript
   #+CINDEX:React, framework type
   #+CINDEX:framework, React
   [00:31] From within the new directory, we'll run {{{command(amplify init)}}}
   to [[https://aws-amplify.github.io/docs/js/start][initialize]] a new [[https://www.amplify.com/][Amplify]] project.  We'll then be prompted for a few
   options.  For the default editor, I'll choose Visual Studio code.  For the
   type of app we're building, we can choose JavaScript.  For the framework
   we're using, we can choose React.

    #+CINDEX:directories, source, distribution
    #+CINDEX:build command
    #+CINDEX:start command
    #+CINDEX:commands, build, start
    [00:49] The source directory can be left as ~source~.  The distribution
    directory, ~build~.  The {{{command(build)}}} command can be left as
    ~build~.  The {{{command(start)}}} command can be left as ~start~.

    #+CINDEX:AWS profile, choose
    [01:04] Next, we're given the option to choose an AWS
    profile.  Here, we can choose the profile that we created when we
    configured this CLI.

    #+CINDEX:Amplify project, initialized
    #+CINDEX:rc file, Amplify
    #+CINDEX:@file{.amplify} rc file
    #+CINDEX:Amplify folder
    #+CINDEX:folder, Amplify
    #+CINDEX:root directory
    [01:18] Now, our Amplify project has been initialized.  We should
    now see a ~.amplify~ rc file, as well as an Amplify folder, in our
    root directory.

** Install Client Libraries

   #+CINDEX:client libraries, install
   #+CINDEX:install client libraries
   [01:29] The last thing we need to do is install the AWS Amplify and
   AWS Amplify React Client Libraries into our React application.

   #+CINDEX:@command{npm}
   #+CINDEX:@command{yarn}
   #+CINDEX:@code{AWS-Amplify} client library
   #+CINDEX:@code{AWS-Amplify-React} client library
   [01:39] To do so, we can either use ~npm~ or ~yarn~ to add AWS Amplify
   and AWS Amplify React.

   [01:53] Now, the React app has been configured, the Amplify project
   has been created, and we're ready to begin adding new features.

* Use the AWS Amplify ~withAuthenticator~ HOC to Implement a React User Authorization Flow

  #+CINDEX:user authentication, enable
  #+CINDEX:Amazon Cognito
  #+CINDEX:@code{withAuthenticator} HOC
  #+CINDEX:sign-up flow, create
  #+CINDEX:sign-in flow, create
  In this lesson we’ll enable *user authentication* ([[https://aws.amazon.com/cognito/][Amazon Cognito]]) in
  the existing AWS Amplify project, then use the ~withAuthenticator~
  /higher order component/ [fn:9] from AWS Amplify [fn:8] to quickly add a
  preconfigured sign up and sign in flow.

** Add Authentication

   #+CINDEX:authentication, add service
   #+CINDEX:add new service, using Amplify
   #+CINDEX:Amplify add new service using
   #+CINDEX:@command{amplify add}
   #+CINDEX:service, @code{auth}
   #+CINDEX:@code{auth} service
    [00:02] The first service that we're going to add is *authentication*.  To
    add a new service using Amplify, we can run {{{command(amplify add)}}} with
    the name of the service.  The service name that we're going to be adding is
    ~auth~, so we can run {{{command(amplify add auth)}}}.  See [[https://aws-amplify.github.io/docs/js/authentication][Docs
    Authentication]].

    #+CINDEX:default authentication and security configuration
    #+CINDEX:configuration, default authentication and security
    #+CINDEX:authentication
    #+CINDEX:security
    #+CINDEX:@command{amplify push}
    #+CINDEX:push configuration into account
    #+CINDEX:provision new resources
    #+CINDEX:resources, provision new
    #+CINDEX:resources, create
    [00:16] Here, we'll be asked if we would like to use the default
    authentication and security configuration.  We'll choose =yes=.  Now the
    new configuration has been created in our project.  We'll run
    {{{command(amplify push)}}} to push the new configuration into our account
    and create and provision the new resources.

    #+CINDEX:create new authentication service
    #+CINDEX:authentication service, create new
    [00:36] Next, we'll be prompted and asked if we would like to
    continue. If you look at the operation, you can see that it is set
    to =create=.  This means it will create a new authentication service
    in our account.  This may take a couple of minutes to complete.

    #+CINDEX:@file{AWS-exports.js}
    [00:52] Now that the authentication service has been created, we should be
    able to look in our source directory and see a new file that was created
    for us called {{{file(AWS-exports.js)}}}.  This file is created and updated
    by the CLI, so there's no reason for us to change it.

** Configure React App with AWS Resources

    #+CINDEX:React application, configure with AWS resource
    #+CINDEX:AWS resources, configure React app
    #+CINDEX:@file{source/index.js}
    #+CINDEX:@file{index.js}
    #+CINDEX:Amplify, import from AWS Amplify library
    #+CINDEX:library, AWS Amplify, import
    #+CINDEX:import AWS Amplify library
    #+CINDEX:@code{amplify.configure}
    [01:07] We will, though, be using it in the next step to configure
    our React application with the AWS resources.  To configure our
    React app with the AWS resources, we can open up
    ~source/index.js~.  Here, we'll import Amplify from the AWS
    Amplify library.  The configuration from AWS exports, and we'll
    call ~amplify.configure~, passing in the config.

** Install Higher Order Component

    #+CINDEX:@code{withAuthenticator} higher order component
    #+CINDEX:higher order component, @code{withAuthenticator}
    #+CINDEX:HOC @code{withAuthenticator}
    #+CINDEX:@file{source/app.js}
    #+CINDEX:import @file{withAuthenticator} HOC
    #+CINDEX:wrap app component with HOC @file{withAuthenticator}
    [01:47] Next, we'll open ~source/app.js~.  Here we'll first import
    the ~withAuthenticator~ higher order component from the AWS
    Amplify React library.  Instead of exporting the app component as
    a default export, we'll instead wrap the app component with the
    ~withAuthenticator~ higher order component.

** Test Application

   #+CINDEX:test application
   #+CINDEX:@command{run npm start}
   #+CINDEX:application, run
   #+CINDEX:user authentication flow, app protected by
   #+CINDEX:new account, create
   [02:24] Now we're ready to test it out.  To run the app,
   : run npm start
   Our app should now be protected by user authentication flow.  The
   first thing we'll do is click =create account= and create a new
   account.

   #+CINDEX:authentication code, in email
   #+CINDEX:confirm new account
   #+CINDEX:new account, confirm
   #+CINDEX:account, sign in
   #+CINDEX:sign in, account
   [02:57] After the account has been created, you should receive an
   authentication code in your email.  To confirm the sign up, paste in
   the authentication code from your email.  After you've confirmed
   your account, sign into your account.

   #+CINDEX:sign in
   #+CINDEX:redirected to main app
   #+CINDEX:main app, redirected to
   #+CINDEX:user session, in local storage
   #+CINDEX:local storage, user session
   [03:16] After we've signed in, we should be redirected to the main
   app. You'll notice that if you refresh the page, the user remains
   signed in. This is because the user session is stored in local
   storage.

** Create Sign-Out

   #+CINDEX:sign-out button, create
   #+CINDEX:@file{App.js}
   #+CINDEX:@file{withAuthenticator}
   #+CINDEX:@code{include-greetings} key
   #+CINDEX:key, @code{include-greetings}
   [03:28] Next, let's add a sign out button.  To do so we'll go back
   into ~App.js~ and pass in a second argument to ~withAuthenticator~.
   Here, we'll pass in an object with an ~include-greetings~ key set
   to true.

   #+CINDEX:sign-out button
   #+CINDEX:Amplify services, view enabled
   #+CINDEX:enabled Amplify services, view
   #+CINDEX:@command{amplify status}
   #+CINDEX:resource name
   [03:58] Now when we refresh, we should see a sign out button at the
   top right corner of the page.  To view enabled Amplify services at
   any time, we can run ~Amplify status~.  Here, we're given the
   resource name for the authentication that we just created.

** Cognito Authentication Service
   #+CINDEX:Cognito authentication service, view
   #+CINDEX:AWS account, Cognito authentication service
   #+CINDEX:Cognito dashboard
   #+CINDEX:Amazon Cognito user pool
   #+CINDEX:dashboard, Cognito
   #+CINDEX:@command{manage user pools}
   #+CINDEX:user pool
   [04:16] To view the Cognito authentication service in your AWS
   account, open the AWS console and search for Cognito.  In the
   Cognito dashboard, click on =manage user pools= and then click on
   the user pool for the application that we just created.

   #+CINDEX:users, view
   #+CINDEX:signed-up users, view
   [04:32] Here, we can view the settings for the Amazon Cognito user
   pool that we've created and also view any of the users that have
   signed up.

* Manually Sign Up New Users in React with AWS Amplify Auth Class

  #+CINDEX:@code{Auth} class
  #+CINDEX:create custom user sign-in, sign-up flow
  #+CINDEX:sign-in flow, create
  #+CINDEX:sign-up flow, create
  In this lesson we’ll look at how we can use the ~Auth~ class [to] directly
  create a custom user sign-in and sign-up flow.

** Import Authentication Functionality For Sign-Up
  #+CINDEX:@command{import auth}
  #+CINDEX:@code{auth}, import
  #+CINDEX:AWS Amplify library
  #+CINDEX:library, Amplify
  #+CINDEX:initial state, create
  #+CINDEX:state, create initial
  #+CINDEX:user, signup
  #+CINDEX:user information, add
  [00:02] The first thing we'll do is we'll {{{command(import auth)}}} from the
  AWS Amplify library.  Next, we'll create some initial state.  We'll need to
  keep up with the username, password, email, phone number, and authentication
  code for the user that is being signed up.

** Code Authentication for Sign-Up Functionality
  #+CINDEX:@code{onChange} handler
  #+CINDEX:handler, @code{onChange}
  #+CINDEX:text input, handle
  #+CINDEX:@code{setState}
  #+CINDEX:@code{event.target.name}, set
  #+CINDEX:@code{event.target.value}, set
  [00:30] Next, we'll need an ~onChange~ handler to handle the user's text
  input.  This function will call ~this.setState~, setting the
  ~event.target.name~ and the ~event.target.value~.

  #+CINDEX:sign-up, create class method
  #+CINDEX:confirm sign-up, create class method
  #+CINDEX:class method, sign-up
  #+CINDEX:async, sign-up method
  #+CINDEX:@code{try-catch} block
  #+CINDEX:destructure user info
  #+CINDEX:@code{auth.signUp}, call
  #+CINDEX:call @code{auth.signUp}
  #+CINDEX:attributes object
  #+CINDEX:successful sign-up
  [00:49] We'll next create a =sign-up= and =confirm sign-up= class method.
  =Sign-up= will be /async/, so we'll create a ~try-catch~ block.  We'll first
  destructure the username, password, email, and phone number from the state.
  We'll then call ~auth.signUp~, passing in the username and password as well
  as an ~attributes~ object containing the email and the phone number.  If the
  sign up is successful, we'll ~console.log~ ``Successfully signed up.''

  #+CINDEX:@code{confirm sign up}
  #+CINDEX:multi-factor authentication
  #+CINDEX:authentication, multi-factor
  #+CINDEX:destructure user info
  #+CINDEX:@code{try-catch} block
  #+CINDEX:@code{auth.confirmSignup}, call
  #+CINDEX:call @code{auth.confirmSignup}
  #+CINDEX:user, successful sign-up
  [01:57] =Confirm sign up= will handle the /multi-factor authentication/, so
  we'll destructure both the username and the authentication code from the
  state.  Here we'll also set up a ~try-catch~ block.  We'll call
  ~auth.confirmSignup~, passing in the username and the authentication code.
  If this is successful, we'll ~console.log~ ``User successfully signed up.''

** Two Sign-up Forms

   1. Sign-up form
   2. Confirnm sign-up form

   #+CINDEX:forms, for signing up
   #+CINDEX:variable @code{step}
   #+CINDEX:@code{step} variable
   #+CINDEX:toggle forms
   [02:41] This component will contain two forms, one for signing up and one
   for confirming the sign up.  We'll create a variable called ~step~ that
   we'll use to toggle these two forms.

   #+CINDEX:@code{render} method
   #+CINDEX:@code{state.step}
   #+CINDEX:form, sign-up, show
   #+CINDEX:sign-up form, show
   #+CINDEX:@code{onChange} method, sign-up form
   #+CINDEX:properties, name and style
   [03:04] In our ~render~ method we'll check to see if ~this.state.step~ is
   equal to zero.  If it is, we'll show the =sign-in= form.  The sign up form
   will contain four inputs, each with an ~onChange~ method, a =name= property,
   and a =style= property.

   #+CINDEX:placeholder @code{attributes}
   #+CINDEX:@code{attributes} placeholder
   #+CINDEX:sign-up button, create
   #+CINDEX:button, create sign-up
   #+CINDEX:confirm sign-up button, create
   #+CINDEX:sign-up button, confirm, create
   [03:43] We'll also add a placeholder ~attributes~.  Finally, we'll create a
   sign-up button that will call ~this.signup~ when clicked.  To create the
   =confirm sign-up= form, we can just copy and paste the sign-up form to get
   started.

   #+CINDEX:confirm sign-up button
   #+CINDEX:@code{confirmSignup}, call
   #+CINDEX:call @code{confirmSignup}
   [04:31] This form will only need two inputs, one for the username
   and one for the authentication code.  The button for this form will
   call ~this.confirmSignup~.

   #+CINDEX:@code{setState}, call
   #+CINDEX:call @code{setState}
   #+CINDEX:sign-up, successful, set @code{step}
   #+CINDEX:@code{styles} variable
   #+CINDEX:variable @code{styles}
   #+CINDEX:input components
   #+CINDEX:components, input
   [04:52] Finally, in sign up we'll call ~this.setState~, setting the
   ~step~ to one if the sign up is successful.  Next, we'll scroll to
   the bottom of the component and we'll add a ~styles~ variable,
   setting the styles for the input components.

** Test Sign Up and Confirm Sign Up

   #+CINDEX:@command{npm start}, run
   #+CINDEX:run @command{npm start}
   #+CINDEX:new user sign-up
   #+CINDEX:sign-up, new user
   #+CINDEX:form, @samp{confirm sign up}
   #+CINDEX:@samp{confirm sign up} form
   [05:21] To test this out, let's run {{{command(npm start)}}}.  When we sign
   up a new user, we should see ``Successfully signed up'' logged out to the
   console.  We should also see the =confirm sign up= form appear on our
   screen.

   #+CINDEX:confirm sign-up
   #+CINDEX:sign-up, confirm
   [05:52] To confirm sign up, use the username you just created as well as the
   authentication code you received in your email and click =confirm sign up=.
   If the sign up is successful, you should see ``User successfully signed up''
   logged out to the console.

** Make Sure New User Exists in AWS Dashboard

   #+CINDEX:user exists, confirm
   #+CINDEX:dashboard, AWS
   #+CINDEX:AWS dashboard
   #+CINDEX:Cognito console
   #+CINDEX:console, Cognito
   #+CINDEX:new user, look at in console
   #+CINDEX:user pools, manage
   #+CINDEX:manage user pools
   [06:06] To make sure that this user exists, let's jump into the AWS
   dashboard and go to the Cognito console to look at the new user.  In the
   Cognito dashboard we'll click on =manage user pools= and then we'll click on
   the name of the user pool for our app.  When we click on users and groups,
   we should now see the new user appear.

* Create & Interact with an AWS AppSync GraphQL API with AWS Amplify

  - Create GraphQL API
  - Using Amplify CLI
  - To query data from API
  - And perform mutations

  #+CINDEX:GraphQL API, create new
  #+CINDEX:create new GraphQL API
  #+CINDEX:Amplify  CLI
  #+CINDEX:Amplify GraphQL API
  #+CINDEX:query data
  #+CINDEX:data query
  #+CINDEX:render data in app
  #+CINDEX:mutations, perform for client
  In this lesson we’ll create a new [[https://graphql.org/][GraphQL]] API using the Amplify CLI and use
  the [[https://aws-amplify.github.io/docs/js/api][Amplify GraphQL API]] to query data from the new API and render it in our
  app.  We’ll also look at how to perform mutations from the client.

** Create AWS AppSync API
  #+CINDEX:AppSync API
  #+CINDEX:@command{amplify add api}
  #+CINDEX:GraphQL service
  #+CINDEX:@code{amplifyTodoApp}
  [00:01] To create an [[https://docs.aws.amazon.com/appsync/latest/devguide/using-your-api.html][AWS AppSync API]], we can run the command
  {{{command(amplify add api)}}}. For the type of service, choose
  GraphQL. Next, we're prompted to give the API a name. I'll give mine a name
  of =amplifyTodoApp=.

  #+CINDEX:authorization type
  #+CINDEX:GraphQL schema
  #+CINDEX:schema, GraphQL
  #+CINDEX:guided schema creation
  [00:18] For the authorization type, we'll choose =API key=.  When we're asked
  if we have an annotated GraphQL schema, we'll choose =No=. If we'd like to
  have a guided schema creation, we'll choose =Yes=.

  #+CINDEX:edit schema
  #+CINDEX:todo GraphQL schema
  [00:32] For what best describes our project, we're going to choose a single
  object with fields. Next, we're given an option to go ahead and edit the
  schema. Choose =Yes=. We're given an example todo GraphQL schema. We'll take
  the existing schema and add a new property of completed and then save the
  file.

  #+CINDEX:@command{amplify push}
  [00:53] Once the file's been saved, jump back to the command line and press
  {{{key(Enter)}}}.  Now the resources have been saved locally and we can run
  {{{command{amplify push)}}} to create the resource in our account.

  #+CINDEX:AWS AppSync
  [01:13] Once {{{command(amplify push)}}} has successfully completed, open the
  AWS console. From the AWS console, search for =AWS AppSync= so we can go
  ahead and take a look at the new API that we just created.

  #+CINDEX:dashboard, API
  #+CINDEX:Schema, dashboard
  [01:34] In the API dashboard, you can click on =Schema= to take a look at the
  schema that's been auto-generated for us.

** Execute Queries and Mutations

  #+CINDEX:Query, queries
  #+CINDEX:mutations
  #+CINDEX:documentation, API
  #+CINDEX:API documentation
  #+CINDEX:Docs link
  [01:48] Next, click on =Query= so we can begin executing queries and
  mutations against the API. The first thing we'd like to do is create a new
  =todo=. We'll create a mutation called =create=. To view the API
  documentation, you can click on the Docs link on the right side of the
  screen.

  #+CINDEX:mutations
  #+CINDEX:@code{createTodo}
  #+CINDEX:@code{updateTodo}
  #+CINDEX:@code{deleteTodo}
  [02:03] When we click on =Mutations=, we see that we have three different
  types of mutations,
  - ~createTodo~,
  - ~updateTodo~, and
  - ~deleteTodo~. 


  ~createTodo~ takes an input with a name, description and completed
  properties.

  #+CINDEX:mutation, execute
  #+CINDEX:Play button
  [02:34] To execute the mutation, we can click on the orange {{{key(Play)}}}
  button.

  #+CINDEX:query
  #+CINDEX:@code{listTodos} query
  [02:49] Now that we've created a couple of items, let's perform a
  query. We'll perform the ~listTodos~ query that returns an ~items~
  array. We'll then return the ID, the name, the description, and the completed
  values for each todo in the array.

** Query for Data

  #+CINDEX:data query
  #+CINDEX:query for data
  #+CINDEX:@code{graphqlOperation}
  #+CINDEX:Amplify
  #+CINDEX:@code{listTodos} query
  [03:27] Now that we've populated our API with a little bit of data, let's
  query for the data from our React app. The first thing we'll do is that we'll
  import API and ~graphqlOperation~ from AWS Amplify. Next, we'll define our
  ~listTodos~ query to return the ID, the name, the description, and the
  completed properties for every item in the todos array.

  #+CINDEX:initial state
  #+CINDEX:@code{componentDidMount} life cycle method
  #+CINDEX:life cycle method, @code{componentDidMount}
  #+CINDEX:@code{api.graphql}
  #+CINDEX:@code{listTodos}
  #+CINDEX:@code{graphqlOperation}
  [04:03] In the class, we'll create some initial state to hold the ~todos~
  array and set it as an empty array. We'll create a ~componentDidMount~ life
  cycle method where we'll call ~API.graphql~, passing in the ~listTodos~
  ~graphqlOperation~.

  #+CINDEX:@code{setState}, call
  #+CINDEX:render method
  #+CINDEX:map, over array
  #+CINDEX:array, map over
  [04:37] Once the data's returned from our API, we'll call
  ~this.setState~, updating the ~todos~ array with the data returned
  from the API. In the render method, we'll map over the ~todos~
  array, showing the ~todo~ name and the ~todo~ description.

** Run the Application
  #+CINDEX:app, run
  #+CINDEX:run app
  #+CINDEX:@command{npm start}
  [05:14] Now we're ready to run the app. I'll go ahead and open the terminal
  and run {{{command(npm start)}}}. If everything is working correctly, we
  should see the todos on our screen.

* Create & Interact with a Serverless REST API with AWS Lambda from React

  - Create a Lambda function
  - Use AWS Amplify
  - To interact with the Lambda function
  - From a React application

  #+CINDEX:Lambda function, create
  #+CINDEX:Amplify, interact with Lambda function
  #+CINDEX:microservices
  In this lesson we’ll learn how to create a Lambda function and use AWS
  Amplify to interact with the Lambda function from a React app.  {{{dfn(Lambda
  functions)}}} allow us to easily create one-off functionality or interact
  with microservices. We’ll use the Lambda function to translate text from
  English to Spanish.

** Add a REST API Using a Lambda Function

   #+CINDEX:REST API
   #+CINDEX:AWS Lambda function
   #+CINDEX:Lambda function, AWS
   #+CINDEX:@command{amplify add} command
   #+CINDEX:service type, @samp{rest}
   #+CINDEX:@samp{PeopleAPI}
   [00:02] To add a REST API using a AWS Lambda function, we can run the
   ~amplify add~ API command. For the type of service, we'll choose =rest=. The
   API that we'll be creating will be fetching a list of people. We'll call the
   API =PeopleAPI=. For the path, we'll give it a path of ~/people~.

   #+CINDEX:data source, Lambda function
   #+CINDEX:Lambda function, create new
   #+CINDEX:@code{peoplefunction}
   #+CINDEX:Lambda function, name
   #+CINDEX:function template
   #+CINDEX:Serverless Express function
   [00:26] For the Lambda function data source, we'll create a new Lambda
   function. Next, we're asked for a label for the Lambda function. We'll call
   this =peoplefunction=. For the name of the Lambda function, we'll also call
   it =peoplefunction=. For the function template that we'd like to use, we'll
   use a Serverless Express function.

   #+CINDEX:@file{app.js}, open for editing
   [00:47] Next, we'll be asked if we'd like to edit the local function
   now. We'll choose yes. This should open up
   {{{file(amplify/backend/function/peoplefunction/source/app.js)}}} in our
   text editor.

   #+CINDEX:@code{app.get/people}
   #+CINDEX:@code{/people} route
   #+CINDEX:@code{people} array, create
   #+CINDEX:array, create as @code{people}
   #+CINDEX:data, hard-code
   [01:01] In ~App.js~, we'll see the code for our Lambda function. We'll
   scroll down until we see ~app.get/people~. Right now, ~/people~ is returning
   an object with the ~success~ property and a URL. We'll go ahead and create a
   new array called ~people~ and hard-code some data.

   #+CINDEX:response, update to return @code{people} array
   #+CINDEX:API access, restrict
   #+CINDEX:authentication enabled
   #+CINDEX:authenticated users read access
   #+CINDEX:access, authenticated users
   #+CINDEX:read access, authenticated users
   [01:35] Next, we'll update the response to return the array of
   ~people~. Save this file and drop back to the command line. We're next asked
   if we'd like to restrict API access. Since we have authentication enabled,
   we'll choose =yes=. For access, we'll give authenticated users only
   access. For the type of access, we'll choose ~read~.

   #+CINDEX:configuration, local, created
   #+CINDEX:@command{amplify push}
   #+CINDEX:resources, create
   #+CINDEX:@file{App.js}
   #+CINDEX:Amplify, import API from
   #+CINDEX:import API from Amplify
   [02:02] With the local configuration created, we can run ~amplify push~ to
   push the new configuration to our account and create the resources. Once the
   resources have been created, open up ~App.js~. Here, we'll first import API
   from AWS Amplify.

** Code the Lambda Function

   #+CINDEX:initial state, people array
   #+CINDEX:@code{componentDidMount} lifecycle method
   #+CINDEX:@code{api.get}, call
   #+CINDEX:call @code{api.get}
   [02:29] In our class definition, we'll define an initial state of people and
   set it to an empty array. We'll create a ~componentDidMount~ lifecycle
   method that we'll call ~API.get~. Here we'll pass in the name of the API as
   well as the path that we would like to fetch.

   #+CINDEX:data, returned as array of @code{people}
   #+CINDEX:@code{setstate}, call
   #+CINDEX:call @code{setstate}
   [02:54] The data returned from the API will be an object with an array of
   ~people~. When the data is returned from the API, we'll call
   ~this.setstate~, setting the value of people to ~data.people~.

   #+CINDEX:render method
   #+CINDEX:@code{people} array, map over
   #+CINDEX:map over @code{people} array
   [03:16] In our ~render~ method, we'll map over the ~people~ array, showing
   the person's name as well as the hair color for every item in the array.

   #+CINDEX:@command{npm start}, launch app
   #+CINDEX:launch app with @command{npm start}
   [03:31] Now we'll save the file, and we'll run ~npm start~ to launch the
   app.

** Fetch Data From Third Party API

   #+CINDEX:data, rendered to screen on launch
   #+CINDEX:data, fetch from 3rd party API
   #+CINDEX:Axios package, install
   #+CINDEX:HTTP requests, Axios package
   #+CINDEX:@file{source}
   [03:39] If everything is working properly, we should see the data rendered
   to our screen. Right now, our API is only returning hard-coded data. Let's
   update the API to fetch data from a third-party API. To do so, we're going
   to need to install the Axios package to send HTTP requests. Change into
   ~amplify/backend/function/peoplefunction/source~.

   #+CINDEX:Axios package, install
   #+CINDEX:@code{require axios}
   [04:06] From within this directory, we'll go ahead and install the Axios
   package. We'll next open ~App.js~ from the
   ~backend/function/peoplefunction/source~ folder. Here, we'll first ~require
   Axios~ from the Axios package.

   #+CINDEX:@code{axios.get}
   #+CINDEX:Star Wars API
   #+CINDEX:promise, from Axios
   #+CINDEX:JSON object, with error from Axios
   [04:38] We'll then call Axios.get, passing in the URL for the open source
   Star Wars API. Axios will return a promise. We'll set a ~.then~ and a
   ~.catch~ function. If there's an error, we'll return a JSON object
   containing an error property and setting people to null.

  #+CINDEX:@code{people} variable
  #+CINDEX:variable @code{people}
  #+CINDEX:JSON object
  #+CINDEX:@code{people} array
  [05:10] If it's successful, we'll go ahead and create a new variable called
  ~people~, setting it to ~response.data.results~. We'll then return a JSON
  object with an error property set to null along with the ~people~ array.

  #+CINDEX:@command{amplify push}, changes to Lambda function
  [05:32] Since we've made changes to our Lambda function, we're going to need
  to run ~amplify push~ again.

  #+CINDEX:@command{npm start}, restart React app
  #+CINDEX:data returned from Star Wars API
  #+CINDEX:Star Wars API, data returned from
  [05:43] Once the resources have been updated in your account, we'll
  run ~npm start~ to restart the React app. When the app loads, we should
  now see the data being returned from the Star Wars API.

* Store Data in Amazon S3 with React

  - Amazon S3
  - Store and retrieve items in the cloud
  - Store images in an S3 bucket
  - Using AWS Amplify Storage API

  #+CINDEX:Amazon S3
  #+CINDEX:cloud, store and retrieve items in
  #+CINDEX:images, store
  #+CINDEX:store images
  #+CINDEX:S3 bucket
  #+CINDEX:Amplify Storage API
  #+CINDEX:S3, object storage service
  Amazon S3 offers a way to store and retrieve items in the cloud. In this
  lesson we’ll see how we can easily store images in an S3 bucket using the AWS
  Amplify Storage API. {{{dfn(S3)}}} is object storage built to store and
  retrieve any amount of data from anywhere on the Internet.

** Add Storage Using S3

   #+CINDEX:S3, add storage using
   #+CINDEX:add storage using S3
   #+CINDEX:Amplify @command{add storage} command
   #+CINDEX:@samp{content} storage type
   #+CINDEX:storage type, @samp{content}
   [00:02] To add storage using Amazon S3, we'll run the Amplify ~add storage~
   command. For the type of storage, we'll choose =content=. For the project
   name, you can either use the default or provide a name of your own.

   #+CINDEX:bucket name
   [00:19] Next, we're prompted for a bucket name. If you do use a custom
   bucket name, please be aware that the bucket name needs to be unique.

   #+CINDEX:access to S3 data
   #+CINDEX:access type, @samp{read and write}
   #+CINDEX:@command{amplify push} create S3 resources
   [00:30] For access, we only want to give authorized users access. For the
   type of access, we'll choose =read and write=. Now that the resources have
   been created locally, we'll run ~amplify push~ to create the service in our
   account.

** Code S3 Storage

   #+CINDEX:@file{app.js}, import storage API from Amplify
   #+CINDEX:storage API, Amplify
   #+CINDEX:initial state, create
   [00:49] Once the resource has been successfully created in your account, go
   ahead and open up ~App.js~ in your text editor. The first thing we'll do is
   we'll import the storage API from AWS Amplify. In the class definition,
   we'll create some initial state containing a file URL, a file, and a
   filename.

   #+CINDEX:@code{handleChange} method, file input
   #+CINDEX:@code{file} variable
   #+CINDEX:@code{setstate}, call
   #+CINDEX:call @code{setstate}
   [01:18] We'll create a ~handleChange~ method that will handle the file
   input. We'll save the file data in a variable we'll call ~File~. Then we'll
   call ~this.setstate~, setting the file URL, the file, as well as the
   filename.

   #+CINDEX:@code{saveFile} function, create
   #+CINDEX:save file in S3 bucket
   #+CINDEX:file, save in S3 bucket
   #+CINDEX:@code{storage.put}
   [02:01] We'll next create a function called ~SaveFile~ that will save the
   file in our S3 bucket. ~SaveFile~ will call ~storage.put~, passing in the
   filename as well as the file data.

   #+CINDEX:@command{console.log} file success
   #+CINDEX:@code{setstate}
   [02:20] If this is successful, we'll console.log successfully saved file and
   then call ~this.setstate~, resetting the file URL, the file, and the
   filename. If there's an error, we'll log out the error.

   #+CINDEX:render method
   #+CINDEX:file input, create
   #+CINDEX:@code{onChange} handler
   #+CINDEX:@code{handlechange} handler
   #+CINDEX:@code{onclick} handler
   #+CINDEX:@code{saveFile} handler
   #+CINDEX:handlers, @code{onClick}, @code{onSave}
   [02:51] In our ~render~ method, we'll first create a file input and set the
   ~onchange~ handler to ~this.handlechange~. We'll then create an image with
   the source set to ~this.state.fileURL~. Finally, we'll create a button with
   an ~onclick~ handler set to ~this.SaveFile~.

** Test File Save in S3 Bucket

   #+CINDEX:test file save
   #+CINDEX:@command{npm start}
   #+CINDEX:file upload
   #+CINDEX:file save
   [03:24] Now we can test it out. Open the Terminal and run ~npm start~. Here,
   we should be able to upload and save files. If the save is successful, we
   should see successfully saved file logged out to the console.

** Look at S3 Bucket

   #+CINDEX:bucket, look at
   #+CINDEX:S3 bucket, look at
   #+CINDEX:AWS console
   #+CINDEX:AWS Services, search
   [03:49] Let's take a look at the bucket. To view your S3 buckets, open the
   AWS console and search for S3 in the AWS Services search bar.

   #+CINDEX:bucket, search for
   #+CINDEX:S3 dashboard
   [04:02] In the S3 dashboard, we can now search for the name of the bucket we
   just created. In the public folder, we should now see any images that we
   uploaded.

** Images from S3 Buckets

   #+CINDEX:images, from S3 bucket
   #+CINDEX:S3 bucket, images from
   [04:18] Next, let's look at how to get images from our S3 bucket. To do so,
   click on an image that we've uploaded already and save the name of the file
   to your clipboard.

   #+CINDEX:@file{app.js}
   #+CINDEX:state, remove
   #+CINDEX:@code{componentDidMount} lifecycle method
   #+CINDEX:lifecycle method, @code{componentDidMount}
   #+CINDEX:@code{storage.get}
   #+CINDEX:@code{setstate}
   [04:28] Next, we'll go back to ~App.js~ and make some updates. The first
   thing we'll do is we'll remove all of the state with the exception of the
   file URL. We'll remove the two existing class methods and replace them with
   a ~componentDidMount~ lifecycle method. ~ComponentDidMount~ will call
   ~storage.get~, passing in the name of the image, and then calling
   ~this.setstate~, resetting the value of file URL.

   #+CINDEX:@code{render} method
   #+CINDEX:@command{npm start}
   #+CINDEX:image, render to screen
   [05:08] In our ~render~ method, we can go ahead and delete the input as well
   as the button components. To test it out, open the Terminal and run ~npm
   start~. When the app loads, we should see the image render to our screen.

   #+CINDEX:@code{storage.list}
   #+CINDEX:Storage
   #+CINDEX:list all images on S3 bucket
   #+CINDEX:S3 bucket, list all images
   #+CINDEX:Amplify documentation
   #+CINDEX:documentation, Amplify
   [05:24] Storage also has a ~storage.list~ method that will list out all of
   the images available in the S3 bucket. To learn more, check out the docs at
   [[https://aws-amplify.github.io][Storage Docs]].

* Deploy Your React Application to AWS Using the Amplify CLI

  - Deploy React application
  - To AWS
  - Using Amplify CLI
  - And Amazon S3

  #+CINDEX:deploy React app to AWS
  #+CINDEX:deploy using Amplify CLI, S3
  #+CINDEX:React app, deploy to AWS using Amplify CLI, S3
  In this lesson we learn how to deploy your React application to AWS
  using the Amplify CLI & Amazon S3.

** Add Hosting

   #+CINDEX:add hosting
   #+CINDEX:hosting, add
   #+CINDEX:@command{amplify add hosting}
   #+CINDEX:environment setup
   #+CINDEX:@env{DEV} environment
   #+CINDEX:@env{PROD}
   #+CINDEX:HTTPS, S3
   #+CINDEX:S3 HTTPS
   #+CINDEX:CloudFront distribution
   [00:02] To add hosting, we can run ~amplify add hosting~. For the
   environment setup, we can either choose =DEV= for S3 with HTTP or =PROD= for
   S3 with HTTPS with CloudFront distribution. I'll choose =DEV=.

   #+CINDEX:bucket name
   #+CINDEX:@file{index.html}
   #+CINDEX:@samp{index} doc
   #+CINDEX:@samp{error} doc
   #+CINDEX:doc, @samp{index}, @samp{error}
   [00:16] Next, we're prompted for the bucket name. Give the bucket a unique
   name. For the ~index~ doc and the ~error~ doc, we can choose ~index.html~.

   #+CINDEX:deploy app, from S3 bucket
   #+CINDEX:@command{amplify publish}, from S3 bucket
   #+CINDEX:S3 bucket, deploy
   [00:31] To deploy our new setup, we can run ~amplify publish~. Once the
   deployment is complete, our app should launch in a new window. If we open
   the URL, we see that the app is indeed running from our S3 bucket.

* Amplify Console
  :PROPERTIES:
  :APPENDIX: t
  :END:

  #+CINDEX:Amplify console, launched
  #+CINDEX:deploy Amplify applications, preferred method
  #+CINDEX:atomic deployments
  #+CINDEX:documentation at Amplify
  We've [Amazon] recently launched the Amplify Console, which is now the
  preferred way of deploying Amplify applications and has built-in CI / CD &
  atomic deployments. For more info, check out the documentation at
  https://aws.amazon.com/amplify/console/.

* AWS Identity and Access Management IAM
:PROPERTIES:
:APPENDIX: t
:END:

- [[https://aws.amazon.com/iam/][AWS IAM]]

- [[https://docs.aws.amazon.com/IAM/latest/UserGuide/introduction.html][IAM Documentation]]

#+CINDEX:IAM
#+CINDEX:Identify and Access Management
#+CINDEX:AWS services and resources, manage access to
#+CINDEX:AWS users and groups
#+CINDEX:services, manage access to
#+CINDEX:resources, manage access to
#+CINDEX:users, AWS
#+CINDEX:groups, AWS
#+CINDEX:permissions, AWS resources
AWS Identity and Access Management (IAM) enables you to manage access to AWS
services and resources securely. Using IAM, you can
- create and manage AWS *users and groups*, and
- use *permissions* to allow and deny their access to AWS resources.


- {{{dfn(Resources)}}} ::
     are objects within a service.  IAM resources include
  - groups,
  - users,
  - roles, and
  - policies.

#+CINDEX:AWS account
IAM is a feature of your AWS account offered at no additional charge. You will
be charged only for use of other AWS services by your users.

#+CINDEX:IAM, start
#+CINDEX:AWS Management Console
#+CINDEX:Management Console
#+CINDEX:console, management
#+CINDEX:IAM best practices
#+CINDEX:best practices, IAM
#+CINDEX:practices, IAM best
To get started using IAM, or if you have already registered with AWS, go to the
[[https://console.aws.amazon.com/iam/home][AWS Management Console]] and get started with these [[http://docs.aws.amazon.com/IAM/latest/UserGuide/IAMBestPractices.html][IAM Best Practices]].

** Use Cases

#+CINDEX:AWS resources, access to
#+CINDEX:resources, access to AWS
#+ATTR_TEXINFO: :indic b
- Fine-grained access control to AWS resources ::
     #+CINDEX:AWS service APIs, access to
     #+CINDEX:service APIs, access to
  - IAM enables your users to control *access* to /AWS service APIs/ and to
    specific /resources/.
    #+CINDEX:conditions on use, AWS IAM
    #+CINDEX:originating IP address
    #+CINDEX:SSL, using
    #+CINDEX:authenticated using MFA
    #+CINDEX:MFA
  - IAM also enables you to add specific *conditions* such as time of day to
    control how a user can use AWS, their originating IP address, whether they
    are using SSL, or whether they have authenticated with a multi-factor
    authentication device.

    #+CINDEX:access control, mobile applications
    #+CINDEX:Web Identity Providers
    #+CINDEX:security credentials, temporary
- Manage access control for mobile applications with Web Identity Providers ::
  - You can enable your mobile and browser-based applications to securely
    access AWS resources by requesting *temporary security credentials* that
    grant access only to specific AWS resources for a configurable period of
    time.

    #+CINDEX:Multi-factor authentication
- Multi-factor authentication for highly privileged users ::
  - Protect your AWS environment by using AWS MFA, a security feature
    available at no extra cost that augments user name and password
    credentials.
  - MFA requires users to prove physical possession of a hardware MFA token or
    MFA-enabled mobile device by providing a valid MFA code.

    #+CINDEX:identity management
    #+CINDEX:corporate directory
    #+CINDEX:employees
    #+CINDEX:federated access
    #+CINDEX:SAML 2.0
    #+CINDEX:AWS Console SSO
    #+CINDEX:API federation
- Integrate with your corporate directory ::
     - IAM can be used to grant your employees and applications *federated
       access* to the AWS Management Console and AWS service APIs, using your
       existing identity systems such as Microsoft Active Directory.
     - You can use any identity management solution that supports SAML 2.0, or
       feel free to use one of our federation samples (AWS Console SSO or API
       federation).

** How It Works

#+CINDEX:roles, create
#+CINDEX:permissions, create
{{{heading(IAM assists in creating roles and permissions.)}}}

AWS IAM allows you to:

#+CINDEX:IAM users, manage
#+CINDEX:users, manage IAM
#+CINDEX:access, manage IAM
#+ATTR_TEXINFO: :indic b
- Manage IAM users and their access ::
  - You can [[https://console.aws.amazon.com/iam/home?#/users][*create users*]] in IAM,
  - [[https://console.aws.amazon.com/iam/home?#/users/Pinecone?section=security_credentials][*assign security credentials*]] to individual users (in other words, access
    keys, passwords, and multi-factor authentication devices), or
  - *request temporary security credentials* to provide users access to AWS
    services and resources.
  - You can manage *permissions* in order to control which operations a user
    can perform.

- Manage IAM roles and their permissions ::
  - You can *create roles* in IAM and manage permissions to control which
    operations can be performed by the entity, or AWS service, that assumes the
    role.
  - You can also *define which entity* is allowed to assume the role. In
    addition, you can use service-linked roles to delegate permissions to AWS
    services that create and manage AWS resources on your behalf.

- Manage federated users and their permissions ::
  - You can enable *identity federation* to allow existing identities (users,
    groups, and roles) in your enterprise to
    - access the AWS Management Console,
    - call AWS APIs, and
    - access resources, without the need to create an IAM user for each identity.
  - Use any identity management solution that supports SAML 2.0, or use one of
    our federation samples (AWS Console SSO or API federation).

** Manage Users

[[https://aws.amazon.com/iam/details/manage-users/]]

#+CINDEX:IAM users
#+CINDEX:users, manage IAM
#+CINDEX:manage IAM users
#+CINDEX:users, create
#+CINDEX:security credentials
#+CINDEX:access keys
#+CINDEX:passwords
#+CINDEX:multi-factor authentication devices
#+CINDEX:temporary security credentials
#+CINDEX:permissions, manage
#+CINDEX:operations, allowed
Manage IAM users and their access:

- You can create users in IAM,
- assign them individual security credentials (such as access keys, passwords, and
  multi-factor authentication devices), or
- request temporary security credentials to provide users access to AWS services and resources.
- You can manage permissions in order to control which operations a user can perform.


IAM users can be:

#+CINDEX:administrators, privileged
#+CINDEX:resources, manage AWS
#+CINDEX:end users
#+CINDEX:systems, access data in AWS
1. Privileged administrators who need console access to manage your AWS
   resources.
2. End users who need access to content in AWS.
3. Systems that need privileges to programmatically access your data in AWS.

*** General Use Cases for Creating IAM Users

#+CINDEX:root account, do not use
#+CINDEX:least privilege
{{{subheading(Principle of Least Privilege)}}}

- It is a security best practice to not use your root account because the root
  account grants access to all services and resources. Grant users the minimum
  amount of privilege necessary, which is known as {{{dfn(least privilege)}}}.

{{{subheading(Assign Policies)}}}

  #+CINDEX:policies, assign to users
- You have other people in your group who have varied access and authorization
  permissions. When you use IAM users, it is easier to assign policies to
  specific users that access specific services and associated resources.

{{{subheading(Use the CLI)}}}

  #+CINDEX:AWS CLI
  #+CINDEX:CLI, AWS
- An IAM user can use the AWS CLI.

{{{subheading(Use Roles)}}}

  #+CINDEX:role, IAM user
  #+CINDEX:IAM user role
  #+CINDEX:user role, IAM
- An IAM user can use a role.

*** Create an IAM User

#+CINDEX:create IAM user, canonical
#+CINDEX:IAM user, create, canonical
#+CINDEX:user, create IAM, canonical
The following diagram describes the canonical use case for creating an IAM
user:

1. Create user
2. Give user security credentials
3. Put user into one or more groups
4. Give user a login profile (optional)

*** Using Groups for Easy Administration

#+CINDEX:IAM user group
#+CINDEX:user group, IAM
#+CINDEX:group, IAM user
A {{{dfn(group)}}} is a collection of IAM users.

#+CINDEX:permissions, assign to group of IAM users
Groups let you assign permissions to a collection of users, which can make it
easier to manage the permissions for those users.

#+BEGIN_cartouche
For example, you could have a group called =Admins= and give that group the
types of permissions that administrators typically need. Any user in that group
automatically has the permissions that are assigned to the group. If a new user
joins your organization and should have administrator privileges, you can
assign the appropriate permissions by adding the user to that group. Similarly,
if a person changes jobs in your organization, instead of editing that user's
permissions, you can remove him or her from the old group and add him or her to
the new group.
#+END_cartouche

** Manage Permissions

[[https://aws.amazon.com/iam/details/manage-permissions/]]

#+CINDEX:IAM permissions
#+CINDEX:permissions, IAM
#+CINDEX:AWS resources, access to
{{{dfn(Permissions)}}} let you specify access to AWS resources.

Permissions are granted to IAM entities (users, groups, and roles) and by
default these entities start with no permissions. In other words, IAM entities
can do nothing in AWS until you grant them your desired permissions.

#+CINDEX:policy, attach
To give entities permissions, you can attach a policy that specifies
- the type of access,
- the actions that can be performed, and
- the resources on which the actions can be performed.
- In addition, you can specify any conditions that must be set for access to be
  allowed or denied.

*** Assign Permissions

#+CINDEX:permissions, assign
#+CINDEX:policy, create
To assign permissions to a user, group, role, or resource, you create a policy
that lets you specify:

#+ATTR_TEXINFO: :indic b
- Actions ::
             Which AWS service actions you allow. For example, you might allow
             a user to call the Amazon S3 ListBucket action. Any actions that
             you don't explicitly allow are denied.
- Resources ::
               Which AWS resources you allow the action on. For example, what
               Amazon S3 buckets will you allow the user to perform the
               ListBucket action on? Users cannot access any resources that you
               do not explicitly grant permissions to.
- Effect ::
            Whether to allow or deny access. Because access is denied by
            default, you typically write policies where the effect is to allow.
- Conditions ::
                Which conditions must be present for the policy to take
                effect. For example, you might allow access only to the
                specific S3 buckets if the user is connecting from a specific
                IP range or has used multi-factor authentication at login.

*** Create Policies

#+CINDEX:policies, create
#+CINDEX:create policies
#+CINDEX:visual editor, create policies
#+CINDEX:JSON, create policies
You create policies by using either the visual editor or JSON.

#+CINDEX:policy
#+CINDEX:permissions, set of
A {{{dfn(policy)}}} consists of one or more statements, each of which describes
one set of permissions.

#+CINDEX:AWS IAM Policy Reference
#+CINDEX:policy language
To learn more about the policy language, see [[http://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies.html][AWS IAM Policy Reference]].

**** Visual Editor

#+CINDEX:visual editor
#+CINDEX:permissions, grant
#+CINDEX:IAM policies
#+CINDEX:policies, create using visual editor
#+CINDEX:actions, List and Read
#+CINDEX:S3 bucket actions
The visual editor guides you through granting permissions by using IAM policies
without requiring you to write the policies in JSON (although you can still
author and edit policies in JSON, if you prefer). The policy in the following
screenshot was created with the visual editor. It grants five Amazon S3 List
and Read actions to the S3 bucket and objects in SampleBucket if the prefix
starts with MyPrefix.

#+NAME:img:manage-permissions
#+CAPTION:Policy created using the Visual Editor
[[file:img/ManagePermissions.jpg]]

*** View Policy Summaries

#+CINDEX:policy summaries, view
#+CINDEX:view policy summaries
#+CINDEX:AWS Management Console
#+CINDEX:manage permissions
#+CINDEX:permissions, manage
#+CINDEX:access levels
#+CINDEX:List access level
#+CINDEX:Read access level
#+CINDEX:Write access level
#+CINDEX:Permissions access level
#+CINDEX:policy permissions
#+CINDEX:permissions, policy
#+CINDEX:actions, AWS service
#+CINDEX:AWS service action policy
If you use the AWS Management Console to manage permissions, you can view
policy summaries. A {{{dfn(policy summary)}}} /lists the access level,
resources, and conditions for each service defined in a policy/ (see the
following screenshot for an example). To help you understand the permissions
defined in a policy, each AWS service’s actions are categorized in four access
levels: List, Read, Write, and Permissions management.

#+NAME:img:view-policies
#+CAPTION:View policy summaries
[[file:img/JC1final-UPDATED_65.png]]

#+CINDEX:predefined policy, select
#+CINDEX:policy generator, create own policy
#+CINDEX:policy, predefined by AWS
You can select a predefined policy managed by AWS or create your own using the
policy generator. For more information, see the [[http://docs.aws.amazon.com/IAM/latest/UserGuide/PoliciesOverview.html][Overview of IAM Policies]]
section of the [[http://docs.aws.amazon.com/IAM/latest/UserGuide/][Using IAM guide]].

** Getting started with AWS IAM

https://aws.amazon.com/iam/getting-started/

AWS IAM helps you manage access to your AWS resources.  Using IAM, you can
manage:
#+ATTR_TEXINFO: :indic b
- Authentication :: who can use your AWS resources and
- Authorization :: what resources they can use and in what ways.

{{{heading(Tutorials and guides)}}}

Get started with AWS Identity and Access Management (IAM) quickly using the
following tutorials and guides:

- What is AWS Identity and Access Management (IAM), and what can I do with it [[https://aws.amazon.com/premiumsupport/knowledge-center/iam-intro/][==>]]
- User Guide: Getting Started [[http://docs.aws.amazon.com/IAM/latest/UserGuide/getting-started.html][==>]]
- What is an IAM user and what can an IAM user do [[https://aws.amazon.com/premiumsupport/knowledge-center/iam-user-basics/][==>]]
- How to create a new IAM user [[https://aws.amazon.com/premiumsupport/knowledge-center/create-new-iam-user/][==>]]
- Tutorial: Delegate Access to the Billing Console [[http://docs.aws.amazon.com/IAM/latest/UserGuide/tutorial_billing.html][==>]]
- Tutorial: Delegate Access Across AWS Accounts Using IAM Roles [[http://docs.aws.amazon.com/IAM/latest/UserGuide/tutorial_cross-account-with-roles.html][==>]]
- Tutorial: Create and Attach Your First Customer Managed Policy [[http://docs.aws.amazon.com/IAM/latest/UserGuide/tutorial_managed-policies.htmlhttp://docs.aws.amazon.com/IAM/latest/UserGuide/tutorial_managed-policies.html][==>]]
- Tutorial: Enable Your Users to Configure Their Own Credentials and MFA
  Settings [[http://docs.aws.amazon.com/IAM/latest/UserGuide/tutorial_users-self-manage-mfa-and-creds.html][==>]]


Want to learn more? See
- [[http://docs.aws.amazon.com/IAM/latest/UserGuide/tutorials.html][AWS IAM Tutorials]] and
- the [[https://aws.amazon.com/premiumsupport/knowledge-center/#iam][AWS IAM section in the Knowledge Center]].

** IAM Best Practices

#+CINDEX:recommended best practices
#+CINDEX:real-world scenarios
To get the greatest benefits from IAM, take time to learn the recommended best
practices. One way to do this is to see how IAM is used in real-world scenarios
to work with other AWS services.

*** Lock Away Your AWS Account Root User Access Keys

#+CINDEX:programmatic requests to AWS
#+CINDEX:root user access keys, do not use
You use an access key (an access key ID and secret access key) to make
programmatic requests to AWS. However, do not use your AWS account root user
access key. The access key for your AWS account root user gives full access to
all your resources for all AWS services, including your billing
information. You cannot reduce the permissions associated with your AWS account
root user access key.

Therefore, protect your root user access key like you would your credit card
numbers or any other sensitive secret. Here are some ways to do that:

#+CINDEX:root user access key, do not create
#+CINDEX:IAM user, create with administrative permissions
- If you don't already have an access key for your AWS account root user, don't
  create one unless you absolutely need to. Instead, use your account email
  address and password to sign in to the AWS Management Console and create an
  IAM user for yourself that has administrative permissions.

  #+CINDEX:root user access key, delete
- If you do have an access key for your AWS account root user, delete it.

- Never share your AWS account root user password or access keys with anyone.

- Use a strong password to help protect account-level access to the AWS
  Management Console.

  #+CINDEX:multi-factor authentication, root user account
- Enable AWS multi-factor authentication (MFA) on your AWS account root user
  account.

*** Create Individual IAM Users

#+CINDEX:create individual users
#+CINDEX:IAM user with administrative permissions
Don't use your AWS account root user credentials to access AWS, and don't give
your credentials to anyone else. Instead, create individual users for anyone
who needs access to your AWS account. Create an IAM user for yourself as well,
give that user administrative permissions, and use that IAM user for all your
work.

For information about how to do this, see

#+CINDEX:IAM user, create first
- [[https://docs.aws.amazon.com/IAM/latest/UserGuide/getting-started_create-admin-group.html][Creating Your First IAM Admin User and Group]].

By creating individual IAM users for people accessing your account, you can
give each IAM user a unique set of security credentials. You can also grant
different permissions to each IAM user. If necessary, you can change or revoke
an IAM user's permissions any time.

*** Use Groups to Assign Permissions to IAM Users

#+CINDEX:groups, assign permissions to
Instead of defining permissions for individual IAM users,

#+CINDEX:job functions
- it's usually more convenient to create groups that relate to job functions
  (administrators, developers, accounting, etc.).

- Next, define the relevant permissions for each group.

  #+CINDEX:users, assign to groups
- Finally, assign IAM users to those groups.


All the users in an IAM group inherit the permissions assigned to the
group. That way, you can make changes for everyone in a group in just one
place. As people move around in your company, you can simply change what IAM
group their IAM user belongs to.

#+CINDEX:manage IAM groups
#+CINDEX:groups, manage
- [[https://docs.aws.amazon.com/IAM/latest/UserGuide/id_groups_manage.html][Managing IAM Groups]]

*** Grant Least Privilege

#+CINDEX:least privilege
#+CINDEX:tasks, policies for
When you create IAM policies, follow the standard security advice of granting
/least privilege/, or granting only the permissions required to perform a
task. Determine what users need to do and then craft policies for them that let
the users perform /only/ those tasks.

#+CINDEX:permissions, minimum set
Start with a minimum set of permissions and grant additional permissions as
necessary. Doing so is more secure than starting with permissions that are too
lenient and then trying to tighten them later.

#+CINDEX:access level groupings
#+CINDEX:policy actions
#+CINDEX:List
#+CINDEX:Read
#+CINDEX:Write
#+CINDEX:Permissions manaagement
#+CINDEX:Tagging
You can use access level groupings to understand the level of access that a
policy grants. *Policy actions* are classified as:

- =List=,
- =Read=,
- =Write=,
- =Permissions management=, or
- =Tagging=.


#+CINDEX:read-only access
For example, you can choose actions from the =List= and =Read= access levels to
grant read-only access to your users.

#+CINDEX:policy summaries, use
#+CINDEX:access level permissions
To learn how to use policy summaries to understand access level permissions, see

- [[https://docs.aws.amazon.com/IAM/latest/UserGuide/best-practices.html#use-access-levels-to-review-permissions][Use Access Levels to Review IAM Permissions]].

{{{subheading(Service Last Accessed Data)}}}

#+CINDEX:service last accessed data
#+CINDEX:Access Advisor tab
#+CINDEX:IAM console details page
One feature that can help with this is /service last accessed data/. View this
data on the {{{key(Access Advisor)}}} tab on the =IAM console details= page for
a user, group, role, or policy.

#+CINDEX:AWS CLI, service last accessed data
#+CINDEX:AWS API, service last accessed data
You can also use the AWS CLI or AWS API to retrieve /service last accessed
data/.

#+CINDEX:unnecessary permissions, identify
This data includes information about which services a user, group, role, or
anyone using a policy attempted to access and when. You can use this
information to identify unnecessary permissions so that you can refine your IAM
policies to better adhere to the principle of least privilege.

For more information, see:

#+CINDEX:reducing permissions, service last accessed data
- [[https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_access-advisor.html][Reducing Permissions Using Service Last Accessed Data]]

{{{subheading(CloudTrail Event history)}}}

#+CINDEX:CloudTrail Event history
#+CINDEX:Event history, CloudTrail
To further reduce permissions, you can view your account's events in CloudTrail
*Event history*. CloudTrail event logs include detailed event information that
you can use to reduce the policy's permissions and include only the actions and
resources that your IAM entities need.

For more information, see (in the AWS CloudTrail User Guide):

#+CINDEX:CloudTrail Events in CloudTrail Console
- [[https://docs.aws.amazon.com/awscloudtrail/latest/userguide/view-cloudtrail-events-console.html][Viewing CloudTrail Events in the CloudTrail Console]]

**** Access Management

#+CINDEX:access management
https://docs.aws.amazon.com/IAM/latest/UserGuide/access.html

**** Policy topics for individual services

#+CINDEX:write policies
#+CINDEX:policies, write for service-specific resources
provide examples of how to write policies for service-specific resources

#+CINDEX:Amazon DynamoDB, authentication, access control
- [[https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/UsingIAMWithDDB.html][Authentication and Access Control for Amazon DynamoDB]] in the /Amazon DynamoDB
  Developer Guide/

  #+CINDEX:bucket policies
  #+CINDEX:policies, bucket and user
  #+CINDEX:Amazon Simple Storage Service
- [[https://docs.aws.amazon.com/AmazonS3/latest/dev/using-iam-policies.html][Using Bucket Policies and User Policies]] in the /Amazon Simple Storage Service
  Developer Guide/

  #+CINDEX:Access Control List (ACL)
- [[https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html][Access Control List (ACL) Overview]] in the /Amazon Simple Storage Service
  Developer Guide/

*** Get Started Using Permissions With AWS Managed Policies

#+CINDEX:AWS managed policies
#+CINDEX:managed policies
#+CINDEX:policies, managed
To get started quickly, you can use AWS managed policies to give your employees
the permissions they need to get started. These policies are already available
in your account and are maintained and updated by AWS. For more information
about AWS managed policies, see [[https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_managed-vs-inline.html#aws-managed-policies][AWS Managed Policies]].

AWS managed policies are designed to provide permissions for many common use
cases.  AWS managed policies make it easier for you to assign appropriate
permissions to users, groups, and roles than if you had to write the policies
yourself.

#+CINDEX:full access managed policy
#+CINDEX:managed policy, full access
#+CINDEX:AmazonDynamoDBFullAccess
#+CINDEX:IAMFullAccess
- Full Access ::
                 Full access AWS managed policies such as
                 [[https://console.aws.amazon.com/iam/home#policies/arn:aws:iam::aws:policy/AmazonDynamoDBFullAccess][AmazonDynamoDBFullAccess]] and [[https://console.aws.amazon.com/iam/home#policies/arn:aws:iam::aws:policy/IAMFullAccess][IAMFullAccess]] define permissions
                 for service administrators by granting full access to a
                 service.

                 #+CINDEX:power user managed policy
                 #+CINDEX:managed policy, power user
                 #+CINDEX:AWSCodeCommitPowerUser
                 #+CINDEX:AWSKeyManagementServicePowerUser
- Power User ::
                Power-user AWS managed policies such as [[https://console.aws.amazon.com/iam/home#policies/arn:aws:iam::aws:policy/AWSCodeCommitPowerUser][AWSCodeCommitPowerUser]]
                and [[https://console.aws.amazon.com/iam/home#policies/arn:aws:iam::aws:policy/AWSKeyManagementServicePowerUser][AWSKeyManagementServicePowerUser]] provide multiple levels of
                access to AWS services without allowing permissions management
                permissions.

                #+CINDEX:partial access managed policy
                #+CINDEX:managed policy, partial access
                #+CINDEX:AmazonMobileAnalyicsWriteOnlyAccess
                #+CINDEX:AmazonEC2ReadOnyAccess
- Partial Access ::
                    Partial-access AWS managed policies such as
                    [[https://console.aws.amazon.com/iam/home#policies/arn:aws:iam::aws:policy/AmazonMobileAnalyticsWriteOnlyAccess][AmazonMobileAnalyticsWriteOnlyAccess]] and
                    [[https://console.aws.amazon.com/iam/home#policies/arn:aws:iam::aws:policy/AmazonEC2ReadOnlyAccess][AmazonEC2ReadOnlyAccess]] provide specific levels of access
                    to AWS services.


#+CINDEX:managed policies for job functions
#+CINDEX:job functions, AWS managed policies
#+CINDEX:IT industry job functions
#+CINDEX:AWS Managed Policies for Job Functions
AWS managed policies for job functions can span multiple services and align
with common job functions in the IT industry. For a list and descriptions of
job function policies, see [[https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_job-functions.html][AWS Managed Policies for Job Functions]].

*** Use Customer Managed Policies Instead of Inline Policies

#+CINDEX:managed policies
#+CINDEX:inline policies
For custom policies, we recommend that you use managed policies instead of
inline policies.

#+CINDEX:inline policies, definition
#+CINDEX:IAM identity
{{{dfn(Inline policies)}}} are policies that exist only on an IAM identity
(user, group, or role).

#+CINDEX:managed policies, definition
#+CINDEX:multiple identities
{{{dfn(Managed policies)}}} are separate IAM resources that you can attach to
multiple identities.

For more information, see [[https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_managed-vs-inline.html][Managed Policies and Inline Policies]].

- A key advantage of using these policies is that you can view all of your
  managed policies in one place in the console.

- You can also view this information with a single AWS CLI or AWS API
  operation.


#+CINDEX:convert inline policies to managed policies
#+CINDEX:inline policies, convert to managed policies
If you have inline policies in your account, you can convert them to managed
policies. To do this, copy the policy to a new managed policy, attach the new
policy to the identity that has the inline policy, and then delete the inline
policy.

#+CINDEX:inline policies rather than managed policies
In some circumstances, we do recommend choosing inline policies over managed
policies. For details, see [[https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_managed-vs-inline.html#choosing-managed-or-inline][Choosing Between Managed Policies and Inline
Policies]].

*** Use Access Levels to Review IAM Permissions

#+CINDEX:review IAM policies
To improve the security of your AWS account, you should regularly review and
monitor each of your IAM policies. Make sure that your policies grant the least
privilege that is needed to perform only the necessary actions.

#+CINDEX:policy summary, view
#+CINDEX:access level, for each service
#+CINDEX:service action
#+CINDEX:List access level
#+CINDEX:Read access level
#+CINDEX:Write access level
#+CINDEX:Permissions management access level
When you review a policy, you can view the policy summary that includes a
summary of the access level for each service within that policy. AWS
categorizes each service action into one of four access levels based on what
each action does: List, Read, Write, or Permissions management. You can use
these access levels to determine which actions to include in your policies.

#+BEGIN_cartouche
For example, in the Amazon S3 service, you might want to allow a large group of
users to access List and Read actions. Such actions permit those users to list
the buckets and get objects in Amazon S3. However, you should allow only a
small group of users to access the Amazon S3 Write actions to delete buckets or
put objects into an S3 bucket. Additionally, you should reduce permissions to
allow only administrators to access the Amazon S3 Permissions management
actions. This ensures that only a limited number of people can manage bucket
policies in Amazon S3. This is especially important for Permissions management
actions in IAM and AWS Organizations services.
#+END_cartouche

#+CINDEX:access level classificationm, view
To view the access level classification that is assigned to each action in a
service, see [[https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_actions-resources-contextkeys.html][Actions, Resources, and Condition Keys for AWS Services]].

#+CINDEX:policy summary
#+CINDEX:Policies page for managed policies
#+CINDEX:Users page for policies attached to a user
To see the access levels for a policy, you must first locate the policy's
summary. The policy summary is included on the Policies page for managed
policies, and on the Users page for policies that are attached to a user. For
more information, see [[https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_understand-policy-summary.html][Policy Summary (List of Services)]].

#+CINDEX:policy summary, within
#+CINDEX:Access level column
#+CINDEX:Full access
#+CINDEX:Limited access
#+CINDEX:level of access, policy provides
Within a policy summary, the Access level column shows that the policy provides
Full or Limited access to one or more of the four AWS access levels for the
service. Alternately, it might show that the policy provides Full access to all
the actions within the service. You can use the information within this Access
level column to understand the level of access that the policy provides. You
can then take action to make your AWS account more secure. For details and
examples of the access level summary, see [[https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_understand-policy-summary-access-level-summaries.html][Understanding Access Level Summaries
Within Policy Summaries]].

*** Configure a Strong Password Policy for Your Users

#+CINDEX:strong passwords
#+CINDEX:passwords, strong, rotate
#+CINDEX:rotate passwords
If you allow users to change their own passwords, require that they create
strong passwords and that they rotate their passwords periodically.

#+CINDEX:Account Settings page of IAM console
-  [[https://console.aws.amazon.com/iam/home?#account_settings][Account Settings]] page of the IAM console ::
     Create a password policy for your account.  You can use the password
     policy to define password requirements, such as minimum length, whether it
     requires non-alphabetic characters, how frequently it must be rotated, and
     so on.


For more information, see [[https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_passwords_account-policy.html][Setting an Account Password Policy for IAM Users]].

*** Enable MFA for Privileged Users

#+CINDEX:multi-factor authentication (MFA)
#+CINDEX:privileged IAM users, definition
For extra security, enable multi-factor authentication (MFA) for
{{{dfn(privileged IAM users)}}} (users who are allowed access to sensitive
resources or API operations).

For more information, see [[https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_mfa.html][Using Multi-Factor Authentication (MFA) in AWS]].

*** Use Roles for Applications That Run on Amazon EC2 Instances

#+CINDEX:Amazon EC2
#+CINDEX:credentials, EC2 instance
Applications that run on an Amazon EC2 instance need credentials in order to
access other AWS services. To provide credentials to the application in a
secure way, use IAM roles.

#+CINDEX:role, definition
- Role ::
          A {{[dfn(role)}}} is an entity that has its own set of permissions,
          but that isn't a user or group.  Roles also don't have their own
          permanent set of credentials the way IAM users do.
#+CINDEX:temporary credentials
#+CINDEX:credentials, temporary
- Temporary credentials ::
     In the case of Amazon EC2, IAM dynamically provides temporary credentials
     to the EC2 instance, and these credentials are automatically rotated for
     you.


#+CINDEX:EC2 instance launch
#+CINDEX:launch EC2 instance
#+CINDEX:role, specify for an instance
#+CINDEX:launch parameter, role
#+CINDEX:permissions, role
#+CINDEX:role permissions
When you launch an EC2 instance, you can specify a role for the instance as a
launch parameter.  Applications that run on the EC2 instance can use the role's
credentials when they access AWS resources.  The role's permissions determine
what the application is allowed to do.

For more information, see [[https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use_switch-role-ec2.html][Using an IAM Role to Grant Permissions to
Applications Running on Amazon EC2 Instances]].

*** Use Roles to Delegate Permissions

*** Do Not Share Access Keys

*** Rotate Credentials Regularly

*** Remove Unnecessary Credentials

*** Use Policy Conditions for Extra Security

*** Monitor Activity in Your AWS Account

*** Video Presentation About IAM Best Practices

The following video includes a conference presentation that covers these best
practices and shows additional details about how to work with the features
discussed here.

[[https://youtu.be/_wiGpBQGCjU]]

* AWS Amplify
  :PROPERTIES:
  :APPENDIX: t
  :END:

[[https://aws-amplify.github.io][Amplify Framework]]

** Library

A comprehensive library for building sophisticated cloud-powered apps

Choose your cloud services and easily connect them to your app with just a few
lines of code.

Categories:
- Analytics
- API
- Authentication
- Storage
- Interactions
- PubSub
- Notifications
- XR


Utilities
- Cache
- Hub
- I18n
- Logger
- Service Worker

** Toolchain

#+CINDEX:toolchain
A powerful [[https://aws-amplify.github.io/media/toolchain][toolchain]] built for developers

#+CINDEX:serverless backends
Effortlessly create and maintain sophisticated serverless backends for your
apps.

#+CINDEX:Amplify Command Line Interface (CLI)
#+CINDEX:Amplify CLI
#+CINDEX:CLI, Amplfy
#+CINDEX:toolchain, unified
#+CINDEX:serverless infrastructure
The Amplify Command Line Interface (CLI) is a unified toolchain to create and
manage your serverless infrastructure on AWS.

*** Effortlessly configure backends

#+CINDEX:serverless backend
#+CINDEX:authentication
#+CINDEX:analytics
#+CINDEX:functions
#+CINDEX:REST
#+CINDEX:GraphQL
#+CINDEX:AWS CloudFormation
#+CINDEX:CloudFormation
#+CINDEX:configurations, add, modify, share
Create sophisticated serverless backends fast. The CLI includes support for
authentication, analytics, functions, REST/GraphQL APIs, and much more. The
toolchain uses AWS CloudFormation and enables you to add, modify, and share
configurations.

#+BEGIN_EXAMPLE
$ cd <your-app>
$ amplify init
$ amplify add <category>
$ amplify push
#+END_EXAMPLE

*** Hosting for static assets and websites

#+CINDEX:content, distribute to end users
#+CINDEX:object storage infrastructure
#+CINDEX:Lambda functions, local testing
#+CINDEX:Lambda functions, connect to APIs
#+CINDEX:deploy, one command
Distribute content to end users with low latency and high data transfer speeds
via a secure, durable, and scalable object storage infrastructure. You can
perform local testing of AWS Lambda functions, connect them to your APIs, and
deploy everything in one command.

#+BEGIN_EXAMPLE
$ amplify add hosting
$ amplify publish
#+END_EXAMPLE

*** Easily create APIs and generate client code

#+CINDEX:GraphQL Scheme Definition language (SDL)
#+CINDEX:SDL
#+CINDEX:CloudFormation template
#+CINDEX:data model, implement
Define your API using the GraphQL Schema Definition Language (SDL). The
toolchain will expand and transform a full CloudFormation template that
implements your data model.

#+BEGIN_EXAMPLE
$ amplify codegen add
$ amplify codegen generate
#+END_EXAMPLE

** UI Components

A beautiful component library connected to the cloud

Accelerate app development by leveraging our beautiful out-of-the box UI
components.

** Amplify CLI Tutorial

[[https://aws-amplify.github.io/docs/cli/init][AWS Amplify CLI]]

#+CINDEX:IAM user
#+CINDEX:AWS profile, set up
#+CINDEX:profile, set up AWS
#+CINDEX:initialize AWS-powered apps
The AWS Amplify CLI helps you
- set up an AWS IAM user,
- set up an AWS profile on your local system and then
- initialize Amplify powered apps with all your defined configurations.


#+CINDEX:share Amplify backend configuration
#+CINDEX:reuse backend infrastructure
We’ll also walk through steps as to
- how you could share the Amplify generated backend configuration between other
  frontend projects and
- re-use the same backend infrastructure in-between multiple platforms/users.


#+CINDEX:tutorial, AWS Amplify
#+CINDEX:project, Amplify-enabled
In this tutorial, we’ll walk through setting up an Amplify-enabled project and
go into detail as to what happens behind the scenes when doing so. We’ll go
over the following commands:
#+CINDEX:@command{amplify configure}
#+CINDEX:@command{amplify init}
#+CINDEX:@command{amplify configure project}
- {{{command(amplify configure)}}}
- {{{command(amplify init)}}}
- {{{command(amplify configure project)}}}

*** Install the CLI

#+CINDEX:CLI, install
#+CINDEX:install CLI
[[https://aws-amplify.github.io/docs/cli/init#install-the-cli][Install the CLI]]

#+CINDEX:AWS account, sign up
#+CINDEX:Node.js, install
#+CINDEX:@command{npm}, install
1. [[https://portal.aws.amazon.com/billing/signup?redirect_url=https%253A%252F%252Faws.amazon.com%252Fregistration-confirmation#/start][sign up for an AWS Account]]
2. install Node.js (8.11+) and {{{command(npm)}}} (5.x+)

*** Amplify Configure

#+CINDEX:CLI, configure
#+CINDEX:configure CLI
[[https://aws-amplify.github.io/docs/cli/init#amplify-configure][Amplify configure]]

#+CINDEX:@command{amplify configure}
#+CINDEX:@command{amplify init}, on new projects
#+CINDEX:projects, new, @command{amplify init}
The {{{command(amplify configure)}}} command is a one-time setup step. After
you perform this on your system you only need to run {{{command(amplify
init)}}} going forward on new projects.

#+CINDEX:AWS, set-up, sign-in
#+CINDEX:IAM User, set-up
#+CINDEX:policies, IAM User
#+CINDEX:resources, deploy
#+CINDEX:AWS Profile, create
#+CINDEX:@samp{accessKey}, IAM user
#+CINDEX:@samp{secretKey}, IAM user
#+CINDEX:profile name
#+CINDEX:initialize project, using AWS Profile
The amplify configure step helps you with the following:
- AWS :: Signing up and signing into AWS
- IAM User :: Setting up an IAM user with the appropriate policies for the CLI
              to deploy AWS resources on behalf of the customer.[fn:10]
- AWS Profile :: Creating an AWS Profile on your local system with reference to
                 the =accessKey= and =secretKey= tied to the IAM user created
                 in the above step.

                 This AWS Profile could be given a custom name (by default we
                 name it “default”) and can be used for /initializing/ any
                 number of projects moving forward. *Essentially the AWS
                 profile defines which AWS account and region the AWS resources
                 would be deployed to.*


#+CINDEX:behind the scenes
{{{heading(What happens behind the scenes?)}}}

#+CINDEX:IAM user, created
#+CINDEX:policies, IAM user
#+CINDEX:AWS account
- An *IAM user* is created in your AWS account with the appropriate policies
  required for the CLI to work

  #+CINDEX:AWS Profile, created
  #+CINDEX:@file{~/.aws/config}
  #+CINDEX:profile name, in @file{config} file
- An *AWS Profile* is created on your local machine. If you check your
  {{{file(~/.aws/config)}}} file on your machine, you would observe a region
  associated with your profile name in the following format:

#+BEGIN_EXAMPLE
[profile amplifyprofile]
region=us-east-1
#+END_EXAMPLE

#+CINDEX:@file{~/.aws/credentials} file
#+CINDEX:@samp{accesskey}, AWS profile
#+CINDEX:@samp{aws_access_key}
#+CINDEX:@samp{secretkey}, AWS profile
#+CINDEX:@samp{aws_secret_access_key}
- Similarly, in your {{{file(~/.aws/credentials)}}} file, you would see the
  =accesskey= and =secretkey= associated with your profile in the following
  format:

  #+BEGIN_EXAMPLE
  [amplifyprofile]
  aws_access_key_id=AKIAI6N66xxxxxxxxxxxx
  aws_secret_access_key=4Nmtuxxxxxxxxxxxxxxxxxxxx
  #+END_EXAMPLE


#+CINDEX:new project, initialize
#+CINDEX:initialize new project
#+CINDEX:region, AWS
#+CINDEX:IAM user, profile
When you initialize a new project, the CLI will ask you to select an AWS
profile. Based on upon your selection all the corresponding resources are
deployed to the region and IAM user tied to the selected profile.

*** Amplify Init

#+CINDEX:CLI, initialize
#+CINDEX:initialize CLI
[[https://aws-amplify.github.io/docs/cli/init#amplify-init][Amplify init]]

#+CINDEX:@command{amplify init}
#+CINDEX:initialization step, new project
#+CINDEX:new project, initialize
#+CINDEX:JavaScript project, new, initialize
#+CINDEX:iOS project, new, initialize
#+CINDEX:Android project, new, initialize
#+CINDEX:backend, AWS, connect project to
The {{{command(amplify init)}}} command is a one-time initialization step for
your Amplify-powered cloud app. You run this once for each project (JavaScript,
iOS, or Android) to connect your app with an AWS backend.

#+CINDEX:AWS Profile, select
#+CINDEX:provision cloud resources
#+CINDEX:frontend framework, select
#+CINDEX:frontend configuration
#+CINDEX:build command, build frontend code
This setup helps you with the following:
- Selecting your AWS Profile which would be used to provision cloud resources
  for your app
- Selecting the frontend framework for your app and corresponding frontend
  framework-related configurations (like the build command to build your
  frontend code).

  #+CINDEX:publish app to cloud
  #+CINDEX:build command
  #+CINDEX:@command{amplify run} command
  This information helps the CLI publish the app to the cloud (after executing
  the build command), as well as helping to run the app locally for you to test
  using the {{{command(amplify run)}}} command.

{{{heading(What happens behind the scenes?)}}}

#+CINDEX:CloudFormation stack, deployed
#+CINDEX:parent stack
- A CloudFormation stack is deployed for you (which we like to call the parent
stack)

#+CINDEX:resources, provisioned by parent CloudFormation stack
- The parent CloudFormation stack provisions the following resources:
  #+CINDEX:S3 deployment bucket
  #+CINDEX:bucket, S3 deployment
  - S3 deployment bucket. It is used to store the following contents:
      #+CINDEX:Parent CloudFormation template
    - Parent CloudFormation template
      #+CINDEX:Nested CloudFormation templqtes
    - Nested CloudFormation templates when you add further AWS resources to
      your project.
      #+CINDEX:Lambda Zip files
      #+CINDEX:API Gateway
      #+CINDEX:Lambda services
    - Lambda Zip files (which are used when using API Gateway & Lambda services
      in your project)
      #+CINDEX:AppSync scheme, resolver files
    - AppSync schema and resolver files
  #+CINDEX:Auth Role
  #+CINDEX:Unauth Role
  #+CINDEX:policies, roles, populated
  - Auth & Unauth Role with no policies in it during the initialization
    phase. The policies get populated in it eventually, based on your
    permission/authorization selections when adding resources to your project
    like API, Storage, and Analytics

#+CINDEX:@file{amplify/} directory, created
- An {{{file(amplify/)}}} directory gets created at the root of your project
  with the following structure:

  #+BEGIN_EXAMPLE
  <project-root>
    |_amplify/
    |_ #current-cloud-backend/
        |_ amplify-meta.json
    |_ .config
        |_ local-aws-info.json
        |_ local-env-info.json
        |_ project-config.json
    |_ backend/
        |_amplify-meta.json
    |_team-provider-info.json
  #+END_EXAMPLE

  #+CINDEX:@file{amplify/backend} directory
  #+CINDEX:backend configuration
  #+CINDEX:CloudFormation templates
  #+CINDEX:@command{amplify add <category>} command
  #+CINDEX:@file{back-config.json} file
  #+CINDEX:backend infrastructure
  #+CINDEX:@file{amplify-meta.json} file
  #+CINDEX:metadata
- The {{{file(amplify/backend)}}} directory contains all the local changes to
  your backend configurations–such as the CloudFormation templates---when you
  add resources to your project using the {{{command(amplify add <category>)}}}
  command. It contains the {{{file{backend-config.json)}}} file which is a
  structure to represent your backend infrastructure and certain CLI runtime
  files like the {{{file(amplify-meta.json)}}} file which contains all the
  metadata tied to your resources which you add via the Amplify CLI.

  #+CINDEX:@file{#current-cloud-backend} directory
  #+CINDEX:@file{backend} directory
  #+CINDEX:@command{amplify push} command
- The {{{file(#current-cloud-backend)}}} directory has a similar structure to
  the {{{file(backend)}}} directory. The only differences between it and the
  {{{file(backend)}}} directory are that it has the configurations that reflect
  what resources were deployed in the cloud with your last {{{command(amplify
  push)}}} command and it helps the CLI diff between the configuration of the
  resources already provisioned in the cloud and what is currently in your
  local {{{file(backend)}}} directory (which reflects your local changes).

  #+CINDEX:@file{.config} directory
  #+CINDEX:metadata files
  #+CINDEX:@file{project-config.json} file
  #+CINDEX:app-specific information
- The {{{file(.config)}}} directory consists of the metadata files tied to your
  project. The {{{file(project-config.json)}}} file, which can be safely
  checked into a version control system, represents information specific to the
  app you’re building. For e.g. a sample format shown below reflects the
  framework you’re using for your app:

  #+BEGIN_EXAMPLE
  {
    "projectName": "testapp",
    "javascript": {
        "framework": "react",
        "config": {
            "SourceDir": "src",
            "DistributionDir": "dist",
            "BuildCommand": "npm run-script build",
            "StartCommand": "npm run-script start"
        }
    },
    "providers": [
        "awscloudformation"
    ],
    "frontend": "javascript",
    "version": "1.0"
  }
  #+END_EXAMPLE

#+CINDEX:@file{.config} directory
#+CINDEX:@file{local-aws-info.json} file
#+CINDEX:profile, key pair
#+CINDEX:resources, adding to project
The {{{file(.config)}}} directory also has a {{{file(local-aws-info.json)}}}
file that lets the CLI know which AWS =profile/accesskey-secret key= pair to
use when adding AWS resources to your project.  *Note:* This file should not be
checked into version control since it has information specific to a system on
which the CLI is running on.

If you’re using an AWS profile to initialize your project, the format should be
the following:

#+BEGIN_EXAMPLE
{
    "dev": {
        "configLevel": "project",
        "useProfile": true,
        "profileName": "devprofile"
    },
    "prod": {
        "configLevel": "project",
        "useProfile": true,
        "profileName": "prodprofile"
    }
}
#+END_EXAMPLE

#+CINDEX:@file{local-env-info.json} file
#+CINDEX:@file{.config} directory
#+CINDEX:preferences, user/system
#+CINDEX:configuration preferences
#+CINDEX:@command{amplify configure project} command
The {{{file(local-env-info.json)}}} file present in the {{{file(.config)}}}
directory lets the CLI store user/system preferences which the user inputs when
initializing the Amplify project in his/her system. These configurations could
be later changed using the {{{command(amplify configure project)}}} command.
*Note:* This file should not be checked into version control since it has
information specific to a system on which the CLI is running on.

This file has the following format:

#+BEGIN_EXAMPLE
{
    "projectPath": "/Users/kaustavg/migtest",
    "defaultEditor": "sublime",
    "envName": "dev"
}
#+END_EXAMPLE

#+CINDEX:@file{team-provider-info.json} file
#+CINDEX:deployment related information
#+CINDEX:environments, tied to project
- The {{{file(team-provider-info.json)}}} file consists of deployment-related
  information for all the environments tied to a project which is specifically
  useful and should be checked into a version control system when sharing your
  environments and backend infrastructure within a team. This file isn’t
  required to be shared if you’re publicly sharing your app infrastructure.

  This file has the following format:

  #+BEGIN_EXAMPLE
  {
    "dev": {
        "awscloudformation": {
            "AuthRoleName": "multenvtest-20181115101929-authRole",
            "UnauthRoleArn": "arn:aws:iam::132393967379:role/multenvtest-20181115101929-unauthRole",
            "AuthRoleArn": "arn:aws:iam::132393967379:role/multenvtest-20181115101929-authRole",
            "Region": "us-east-1",
            "DeploymentBucketName": "multenvtest-20181115101929-deployment",
            "UnauthRoleName": "multenvtest-20181115101929-unauthRole",
            "StackName": "multenvtest-20181115101929",
            "StackId": "arn:aws:cloudformation:us-east-1:132393967379:stack/multenvtest-20181115101929/fc7b1010-e902-11e8-a9bd-50fae97e0835"
        }
    },
    "prod": {
        "awscloudformation": {
            "AuthRoleName": "multenvtest-20181115102119-authRole",
            "UnauthRoleArn": "arn:aws:iam::345090917734:role/multenvtest-20181115102119-unauthRole",
            "AuthRoleArn": "arn:aws:iam::345090917734:role/multenvtest-20181115102119-authRole",
            "Region": "us-east-1",
            "DeploymentBucketName": "multenvtest-20181115102119-deployment",
            "UnauthRoleName": "multenvtest-20181115102119-unauthRole",
            "StackName": "multenvtest-20181115102119",
            "StackId": "arn:aws:cloudformation:us-east-1:345090917734:stack/multenvtest-20181115102119/3e907b70-e903-11e8-a18b-503acac41e61"
        }
  }
  #+END_EXAMPLE

*** Amplify Configure Project

#+CINDEX:project, configure
#+CINDEX:configure project
[[https://aws-amplify.github.io/docs/cli/init#amplify-configure-project][Amplify configure project]]

*** Assuming an IAM Role

#+CINDEX:IAM role, assume
#+CINDEX:assume IAM role
#+CINDEX:role, IAM
[[https://aws-amplify.github.io/docs/cli/init#assuming-an-iam-role][Assuming an IAM Role]]

** Tutorial

[[https://www.youtube.com/watch?v=uiTQL7Ne8rY][AWS Amplify React Tutorial]] by the author.

* List of Figures
:PROPERTIES:
:APPENDIX: t
:END:
#+TEXINFO:@listoffloats Figure

* Index
  :PROPERTIES:
  :INDEX:    cp
  :END:

* Copying
  :PROPERTIES:
  :COPYING:  t
  :END:

  *{{{title}}}* by {{{author}}}

  \copy 2019

  Outline {{{VERSION}}} by WLHarvey4

* README                                                           :noexport:

  #+BEGIN_SRC markdown :tangle README.md

  # Building Serverless Web Applications with React & AWS Amplify

  ## Author

  Nader Dabit

  ## Date

  February 6, 2019

  ## Source

  [Egghead.io](https://egghead.io/courses/building-serverless-web-applications-with-react-aws-amplify)

  ## Synopsis

  This course walks you through setup and implementation to get your
  cloud-based application up and running.

  * a new project in AWS Amplify configured to your React app
  * user authentication with Amazon Cognito
  * managed GraphQL with AWS AppSync
  * mage storage and retrieval with Amazon S3
  * text translation via Lambda functions
  * and finally, deployment of your application on AWS using Amazon S3

  You’ll finish the course ready to quickly and easily deploy your
  serverless React application, so users can start using and enjoying
  it right away.

  #+END_SRC

* MACRO DEFINITIONS                                                :noexport:
#+MACRO:VERSION Version 0.2.9 <2019-02-18 Mon 11:14>
#+MACRO:OUTLINE Outline by WLHarvey4
#+MACRO:heading @@texinfo:@heading @@$1
#+MACRO:subheading @@texinfo:@subheading @@$1
#+MACRO:file @@texinfo:@file{@@$1@@texinfo:}@@
#+MACRO:dfn @@texinfo:@dfn{@@$1@@texinfo:}@@
#+MACRO:command @@texinfo:@command{@@$1@@texinfo:}@@
#+MACRO:noindent @@texinfo:@noindent @@
#+MACRO:key @@texinfo:@key{@@$1@@texinfo:}@@
* EXPORT SETUP                                                     :noexport:
#+TEXINFO_FILENAME:react-aws-amplify.info
#+TEXINFO_CLASS: info
#+TEXINFO_HEADER:
#+TEXINFO_POST_HEADER:
#+SUBTITLE:
#+SUBAUTHOR:
#+TEXINFO_DIR_CATEGORY:React
#+TEXINFO_DIR_TITLE:React AWS Amplify
#+TEXINFO_DIR_DESC:Building serverless web applications
#+OPTIONS: ':nil *:t -:t ::t <:t H:4 \n:nil ^:t arch:headline
#+OPTIONS: author:t broken-links:nil c:nil creator:nil
#+OPTIONS: d:(not "LOGBOOK") date:t e:t email:nil f:t inline:t num:t
#+OPTIONS: p:nil pri:nil prop:nil stat:t tags:t tasks:t tex:t
#+OPTIONS: timestamp:t title:t toc:t todo:t |:t
#+LANGUAGE: en
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
#+CREATOR: Emacs 26.1 (Org mode 9.1.14)

* Footnotes

[fn:1] The AWS Amplify CLI is a toolchain which includes a robust feature set
for simplifying mobile and web application development. The CLI uses AWS
CloudFormation and nested stacks, which allows you to add or modify
configurations locally before you push them for execution in your account.

[fn:2] An AWS Identity and Access Management (IAM) user is an entity that you
create in AWS to represent the person or application that uses it to interact
with AWS. A user in AWS consists of a name and credentials.

[fn:3] Requires Node.js® version 8.11.x or later

[fn:4] Configures the AWS access credentials, AWS Region and sets up a new AWS
User Profile

[fn:5] Amazon cloud computing resources are hosted in multiple locations
world-wide. These locations are composed of AWS Regions and Availability
Zones. Each AWS Region is a separate geographic area. Each AWS Region has
multiple, isolated locations known as Availability Zones. Amazon RDS provides
you the ability to place resources, such as instances, and data in multiple
locations. Resources aren't replicated across AWS Regions unless you do so
specifically.

[fn:6] [[https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys][Access Keys (Access Key ID and Secret Access Key).]]

[fn:7] [[https://reactjs.org/][React]]; [[https://facebook.github.io/create-react-app/][Create React App]]; [[https://github.com/facebook/create-react-app][GitHub create-react-app]]

[fn:9] [[https://aws-amplify.github.io/docs/js/authentication][~withAuthenticator~]]

[fn:8] [[https://aws-amplify.github.io/docs/js/ui][AWS Amplify HOCs]]

[fn:10] By default we give administrator access to this IAM user since the CLI
needs access to a variety of services for deployments.

